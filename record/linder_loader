C语言创建步骤:
	编辑：就是创建和修改C程序的源代码-我们编写的程序称为源代码。
	编译：就是将源代码转换为机器语言。编译器的输出结果成为目标代码，存放它们的文件称为目标文件。扩展名为.o或者.obj。
		（该部分编译是指汇编器编译汇编语言或者编译器编译高级语言）
	链接：链接器将源代码由编译器产生的各种模块组合起来，再从C语言提供的程序库中添加必要的代码模块，将它们组成一个可执行的文件。在windows下扩展名为.exe，Unix下无扩展名。
	执行：运行程序

源代码 ——源文件就是存放程序代码的文件。通常我们编辑代码的文件就是源文件
	源代码相对目标代码和可执行代码而言的
	源代码就是用汇编语言和高级语言写出来的地代码

目标文件——指源代码经过编译程序产生的能被cpu直接识别二进制代码(机器代码 + 运行时数据)
	目标代码指计算机科学中编译器或汇编器处理源代码后所生成的代码，它一般由机器代码或接近于机器语言的代码组成
	目标文件包括着机器代码（可直接被计算机中央处理器履行）和代码在运行时使用的数据，如重定位信息，如用于链接或调试的程序符号（变量和函数的名字），另外还包括其他调试信息


////////////////
Linker
	链接器是一个将编译器产生的目标文件打包成可执行文件或者库文件的程序；链接器本质上也是一个程序，本质上和我们经常使用的普通程序没什么不同
	链接器的输入是编译器编译好的目标文件；链接器在将目标文件打包处理后，生成或者可执行文件，或者库，或者目标文件
	链接器可操作的最小元素是一个简单的目标文件，通常我们写的.c源文件编译后就生成了对应的目标文件(linux中的.o文件，Windows中的.obj文件)

功能组成:
	符号决议: 程序中的所有模块基本上都需要用到其他模块提供的接口，也就是模块间的依赖。linker的其中一项任务就是要确保提供给链接器进行连接的目标文件集合之间的依赖是成立的。也就是说，不会出现被依赖的模块中链接器找不到需要的接口
	符号表: 
		该文件中引用的全局变量及函数
		该文件中定义的全局变量及函数
	符号决议过程: 	链接器会首先扫描每一个给定的目标文件，同时维护两个集合: 已经定义的符号集合D，未定义的符号集合U；链接器会将已定义的符号添加到D中，并将目标文件中引用的符号与D来进行对比，如果该符号不存在D中，则将其添加到集合U中。当所有的文件全部扫描完成后，判断U是否为空

	可执行程序的生成: 
		静态链接和静态链接库
			静态链接: 源程序经过编译器生成目标文件，目标文件和库一起生成最终的可执行文件，链接的过程就是把分布在各个可重定位的目标文件中的可重定位的节合并起来，同时完成符号决议和重定位

			静态库: 一组目标文件的集合，即把很多目标文件经过压缩打包后形成的一个文件；静态库可以作为链接器的输入，如果程序需要引用静态库提供的某个函数，链接时只需要在命令行中输入该库。链接器只拷贝被程序引用的目标模块，以及该目标模块索依赖的那些目标模块。

			静态库特点: 静态链接是在编译时期完成的；静态链接形成可执行文件后，运行时与静态库再无联系，方便移植；浪费内存和磁盘空间；更新困难。当程序所依赖的静态库有任何更新，整个程序就要重新链接

		动态链接与动态库
			动态链接: 
				加载时的动态链接: 可以简单理解为动态链接在程序从磁盘复制到内存的过程中发生。当把可执行文件复制到内存后，且在程序开始执行之前，操作系统会去查找可执行文件依赖的动态库信息(名字跟存放路径)，找到之后将动态库从磁盘搬到内存，并进行符号决议，成功之后程序就开始执行。在编译链接生成可执行文件的时候，需要将使用的动态链接的信息加入到链接选项当中，加载可执行文件时依据动态库信息进行动态链接

				运行时的动态链接: 不需要动态链接时提供动态库的信息，也就是说在可执行文件在被启动之前，可执行文件对所依赖的动态库的信息一无所知，只有当程序运行到需要调用动态库所提供的代码时才会启动动态链接过程。由于可执行文件中没有所依赖的动态库的信息，所以需要开发人员在代码中调用特定的API在运行时加载动态库

			特点: 代码共享，所有引用该动态库的可执行目标文件共享一份相同的代码与数据；更新程序方便；在运行时可以动态的选择加载各种应用程序模块
	重定位