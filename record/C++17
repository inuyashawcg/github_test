// C++17

/////////移除项目/////////
auto_ptr
register关键字
bool类型的++操作

一些弃用的异常标准:

一些功能项:
	std::random_shuffle
	老版本中定义的一些功能函数: bind1st()/bind2nd()/mem_fun() ...
	Trigraphs


/////////修复项目/////////
列表初始化
	auto x = foo(); // copy-initialisation
	auto x{foo()}; // direct-initialisation, initializes an initializer_list (until C++17)

	对于大括号列表初始化，如果只有单个元素，那么就可以从单一元素自动推测类型；如果是多个元素，不支持。例如:
		auto x1 = { 1, 2 }; // decltype(x1) is std::initializer_list<int>
		auto x2 = { 1, 2.0 }; // error: cannot deduce element type
		auto x3{ 1, 2 }; // error: not a single element
		auto x4 = { 3 }; // decltype(x4) is std::initializer_list<int>
		auto x5{ 3 }; // decltype(x5) is int

static_assert with no message
	这个特性为静态断言添加了一个新的重载。它允许您在静态断言中包含条件，而不传递消息。例如:
		static_assert(std::is_arithmetic_v<T>, "T must be arithmetic");
		static_assert(std::is_arithmetic_v<T>); // no message needed since C++17

Different begin and end Types in Range-Based For Loop - 范围for语句
	C++11中的范围for循环:
		for (for-range-declaration : for-range-initializer)
		{
			statement;
		}

	上述代码等价于:
		{
			auto && __range = for-range-initializer;
			for ( auto __begin = begin-expr, __end = end-expr; __begin != __end; ++__begin) 
			{
				for-range-declaration = *__begin;
				statement
			}
		}

	这里的begin和end的类型要求是一致的，而C++17更加灵活，支持两者类型不一致:
		{
			auto && __range = for-range-initializer;
			auto __begin = begin-expr;
			auto __end = end-expr;
			for ( ; __begin != __end; ++__begin ) {
				for-range-declaration = *__begin;
				statement
			}
		}

///////// Language Clarification /////////
Stricter Expression Evaluation Order
	参考文档

Guaranteed Copy Elision
	参考文档

Updated Value Categories
