////////////// 20220913 //////////////
  devfs_specops 中注册的函数都是不可重用的，然后再去对比 vnops 中的函数实现，机制不同的不可重用

  tptfs 中 allocvnode() 函数感觉应该还是要放到文件类中，并且做成虚函数。因为如果将 devfs 融合到 tptfs 当中之后，
它们的查找方式也将统一，所以我们在 lookup() 执行的时候是不知道当前处理的文件是设备文件还是普通文件。两者申请 vnode
的逻辑是不一样的。为了方便使用，直接做成虚函数比较合适；
  initvnode() 操作也可以直接融合到文件类当中，那它存在的位置就需要变化一下，因为我们必须保证当文件类已经存在的时候，
才能调用该函数


////////////// 20220914 //////////////
  devfs dir_opts 跟 tptfs dir_opts 应该也是不一样的，毕竟一个是删除普通文件，另外一个是删除设备文件。设备文件就
涉及到释放 cdev 等资源


////////////// 20220915 //////////////
  假如将 devfs 融合进 tptfs，如果持久化内存仍然是需要在设备加载之后才能初始化，那会面临一些问题：
    1、由于不能访问持久化内存，所以加载设备阶段创建的普通文件都需要在堆栈中为 tpt_inode 结构体申请内存，等待持久化
        内存加载完毕之后，同步到对应的虚拟地址区段
    2、devfs 中还包含有链接文件，要着重考虑如何去处理
    3、设备加载阶段中，普通文件的 inode number 暂时无法分配，因为此时还不清楚根文件系统中存在多少文件，inode 被占用
      了多少。所以需要在解析完记录文件之后，再给这些文件分配 inode number。设备文件应该是无所谓的，它们有自己的一套
      分配机制

- 获取属性的方法，比如 readdir()，由于 devfs 并不存在 inode 实例，所以文件类应该是要设计统一的属性获取虚函数接口
- 设备文件类释放时机的问题，也需要考虑


////////////// 20220916 //////////////
  tptfs 中的设备文件类应该是要跟 struct cdev 一一对应的。只要 cdev 还存在，那文件类就不能被释放。所以在阅读 devfs 源码的时候，
要搞清楚 cdev 到底是什么时候被释放的。或者是在某种情况下，cdev 所占用的内存空间还没有被释放，但是对应的 devfs_dirent 已经被移除，
这个时候 tptfs 所作出的反应应该是将设备文件类从父目录子链表和 hashtree 中移除，暂不释放内存

  devfs_free() 是释放 struct cdev_priv (由于 struct cdev 是它其中的一个成员变量，并且不是指针)，会同步把 struct cdev 删除掉。
但是这个函数没有在 devfs 中被使用，而是在 kern_conf.c 中的函数被调用。说明 tptfs 设备文件类的释放不能跟踪 cdev，而是按照 devfs_dirent
的处理逻辑执行

  devfs 中还存在 WHITEOUT 的情况 (white out: 发白，雾状天气)，应该是为了表达一种无法看清的意思。从 devfs 代码逻辑来看，就是当执行
devfs_remove() 或者使用 ruleset 时，会出现 cdev 没有被真正删除，但用户已经不能在 readdir() 结果中查看到该设备文件。

  给文件申请 vnode 的时候，需要调用 insmntque() / insmntque1() 函数将新申请的 vnode 注册到 mount point 当中。所以，假如 tptfs
需要分阶段挂载，那么在第一阶段需要创建一些必要的对象，包括但不限于：
  - rootnode
  - mount point of tptfs
  - /dev filenode