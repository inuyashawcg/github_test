////////////// 20221107 //////////////

block number = 524

(gdb) p ap[0]
$71 = {
  in_lbn = 0,
  in_off = 0
}
(gdb) p ap[-1]
$72 = {
  in_lbn = -524,
  in_off = 0
}
(gdb) p ap[-2]
$73 = {
  in_lbn = -269,
  in_off = 1
}
(gdb) p ap[-3]
$74 = {
  in_lbn = -269,
  in_off = 1
}

readindir (vp=0xffffffd009788b70, lbn=-269, daddr=1056, bpp=0x1def73540)
    at /home/mercury/Documents/code/qihai/dev_rebuild/qihai/sys/fs/ext2fs/ext2_bmap.c:165
165		mp = vp->v_mount;
(gdb) n
166		ump = VFSTOEXT2(mp);
(gdb) 
168		bp = getblk(vp, lbn, mp->mnt_stat.f_iosize, 0, 0, 0);
(gdb) s    
getblk (vp=0xffffffd009788b70, blkno=-269, size=1024, slpflag=0, slptimeo=0, flags=0)
    at /home/mercury/Documents/code/qihai/dev_rebuild/qihai/sys/kernel/vfs_bio.cpp:3666
3666		error = getblkx(vp, blkno, blkno, size, slpflag, slptimeo, flags, &bp);
(gdb) s
getblkx (vp=0xffffffd009788b70, blkno=-269, dblkno=-269, size=1024, slpflag=0, slptimeo=0, 
    flags=0, bpp=0x1def733c0)
    at /home/mercury/Documents/code/qihai/dev_rebuild/qihai/sys/kernel/vfs_bio.cpp:3726
3726		KASSERT((flags & (GB_UNMAPPED | GB_KVAALLOC)) != GB_KVAALLOC,

  ext2fs block map 中生成间接索引数组的情形，getblk() 传入的参数包含有负数，这对于 tptfs 来说是不存在的。
可能更下层的函数能够处理当逻辑块号是负数的情况，但这是对于磁盘文件系统来说的。tptfs 应该是要重新设计该算法，
只处理非负逻辑块号

/TripleIndirect/DoubleIndirect/SingleIndirect disk block: 1576 -> 2807

/.cschrc 占用的虚拟页号是 131091

/ubuntu.iso 起始虚拟页号应该是 131092
  - 独立一级间接索引占用的虚拟页号 = 131092

  - 独立二级间接索引占用的虚拟页号 = 131093
      二级独立索引子项占用的虚拟页号空间范围 = [131094, 131605]

  - 三级间接索引占用的虚拟页号 = 131606 (测试文件 ubuntu.iso 包含三个子二级间接索引项)
      实际测试打印信息:
                    Indirect index page number: 
                    131092	131093	131606	
      131606 - 131094 = 512
      子二级间接索引起始虚拟页号 = 131607

  文件起始块号 = 132840
  文件结束块号 = 1025163
  文件大小 = 3654957056 bytes

  文件块数 = 1025163 - 132840 + 1 = 892323 + 1 = 892324
  3654957056 / 4096 = 892323.5


////////////// tptfs 测试重点 //////////////
  1、文件的三级间接索引功能是否正确
  2、block map 是否可以给文件正确分配数据块
  3、数据同步问题。就比如当存在多个线程创建新文件时，bitmap 会不会出现给不同的文件分配同一个数据块或者 inode entry。
      有可能会造成不同文件之间的数据覆盖
