////////////// 20220509 //////////////
  C++ 类的封装其实是将数据和关联的方法封装到一起，这样做的好处就是方法中的参数可以不用再传输对应的数据，这样就可以减少
方法中的参数的数量，将方法设计的尽可能简单。FreeBSD 中包含很多全局方法表注册的逻辑，这种其实就是典型的C代码实现风格，
C++中应该避免这种方式，而是将这些全局方法表跟关联的数据封装到类中。(C++ 代码简介之道中也提到了一个原则：尽量减少使用
全局变量和全局函数)

  如果将所有的方法表都做成文件系统的子模块，要管理好各个子模块之间的依赖关系，然后确定实例化顺序。一定要避免循环依赖
    lib -> lock -> block_map / inode_alloc -> block_alloc
  

////////////// 20220510 //////////////
  struct tpt_inode 和 ino_opts 其实是可以封装到一个类当中的


////////////// 20220511 //////////////
  现在要考虑文件系统跟文件类的关系，目前的话应该还是文件系统是主类，因为主要的所有的方法都是文件系统提供的。如果以后修改
vfs 层级的代码，所有的方法应该就是直接存放到文件类当中，那文件系统就变成了一个辅助类

  class TptFileSystem {
  public:
    // ...

  private:
    TptVnodeOpts* vnodeops;
    // ...
  };

  未来则会变成：

  class TptFile {
  public:
    // ...
  
  private:
    TptFileSystem* Fs;
    // ...
  };

 