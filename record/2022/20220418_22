////////////// 202204018 //////////////
  目录文件管理子文件的话，最好还是不要采用容器来做。容器的底层实现还是数组，所以在文件删除后是需要移动
内存数据。而且容器会预分配部分空间，造成一些浪费

  当我们使用模板类的时候，类成员中应该是不能使用包含模板参数的宏定义。宏的话应该是预处理阶段就会展开，
但是模板类具体的类型貌似是运行时才确定的，所以会造成冲突。我们可以使用 std::forward_list 来替代。
forward_list 跟 vector 是不一样的，它就是通过链表来管理数据，所以元素不是连续存放的。vector 数据
就跟数据是一样的，数据也是连续存放。(参考：forward_list 与 vector 的区别)


////////////// 202204019 //////////////
  FreeBSD 文件系统其实可以拆分成三大块：
    1、文件系统本身 mount/unmount 等操作相关的实现函数
    2、vnode operations 相关操作函数
    3、其他一些提供支持的函数
  
  所以，我们在设计的时候并不能将整个文件系统设计成一个类。文件系统类就封装文件系统相关操作 (vfs_ops)。
然后文件类就封装文件相关的操作(vop_vector)

  尝试把 vnode->v_data 设置成 VirtualFile 类对象的指针

  只编译 tptfs 模块
  cmake ../ TARGET_ARCH=riscv64
  1942  make VERBOSE=1
  1971  make


////////////// 202204022 //////////////
  tptfs_inode 中的索引页号可以初始化为0，而不是负数，表示这个结构中没有存放有效的虚拟页号。因为设计中索引数组中的
数据类型是 uint64_t，所以不能存放负数值

C++ 中如何判断使用继承还是组合？
  继承可以表述为子类是一个特定的基类，但还是基类。组合不表示A类是B类，而是A类含有一个B类。举个例子，我们用 class dog
表示所有的狗狗，那么 class 金毛就应该是继承于 class dog，因为金毛本身就是一只狗狗，而不是说金毛有一只狗狗。如果是一只
戴着项圈的金毛，项圈跟金毛的关系就是组合，因为项圈不是金毛本身具有的属性。所以，设计 class 项圈就要与金毛独立开来，然后
在 class 金毛中添加项圈的对象或者指针

  tptfs 原有设计中是将对文件数据的锁操作也添加到了文件类当中。其实参考上面的描述，不论是文件数据锁还是结构体成员的保护锁，
本质上是锁对象的成员函数，而不是文件本身具有的属性。文件本身具有的属性是读写等，锁则是对数据读写过程或者类状态更新时进行
保护，所以它跟文件的关系应该是组合，而不是继承
