////////////// 20220314 //////////////
  内核 C 代码中有的函数会包含有很多行代码的函数，需要将其改成 C++ 的代码风格，把其中的一些功能独立的逻辑块
封装成类中的一个 private 成员函数。其实本质上还是设计思想的问题，不是代码风格的问题

  goto 不符合 MISRA2012 规范，所以在处理 FreeBSD 内核源码的时候要把 goto 给屏蔽掉(因为我们不能保证 goto
每次都能够跳转到正确的地址)。goto 一般的作用就是错误处理或者跳转到 retry 的位置，所以 retry 的话就修改一下
函数逻辑，添加循环；错误处理可以把相关代码封装成一个小的私有成员函数，每次到 goto 的地方就调用一下。并且一般
这些逻辑都比较简单，可以声明成 inline 类型的函数

  刘强已经把 C++ 库添加到了内核当中，可以使用 C++ 的 string 管理 tptfs 中的字符串。使用的时候注意不要链接
lld 和 llvm (cmake文件中进行修改)，太大了并且暂时还用不上


////////////// 20220315 //////////////
  在现有的磁盘文件系统当中经常会看见 vput / vrele 等函数被调用，作用就是减少 vnode 的引用计数并且加锁或者解锁。
猜测一种可能性：某些系统调用执行的时候，为了防止 vnode 在中途被意外释放 (引用计数变成0)，vfs 层级对目录项或者是
文件 vnode 往下级代码传递的时候，首先就给它增加了引用计数，相当于是额外多增加了一次空引用。然后在下层函数执行完毕
之后，再做一次空释放的操作，这样 vnode 整体引用计数的最终的值还是正确的。
  从 vfs_lookup 的实现逻辑来看，貌似是有在查找到目标文件所在目录时，会有 vref (增加引用计数)的操作，可能是底层
文件系统要执行 vput 的原因。进一步思考，什么时候要对 vnode 执行 vput 操作？可能就是 syscall 流程最后一次对该
文件进行操作完成后执行，相当于是把 vnode 置于正确状态之下

  ext2_rename() 函数处理源文件、源目录时，需要考虑在创建新名称的目录项时，源文件已经被删除或者停止执行重命名操作。
所以代码逻辑比较复杂，需要多次进行判断源目录中源文件是否还存在。tptfs 感觉可以采用简单一点的策略，执行之前就直接把
源目录和源文件锁住，防止其他线程将现有文件移除或者更改，只不过会损失一些处理效率


  dd if=/dev/zero of=1.img bs=4096 count=1

  clang++ main.cpp FileSync.cpp -o a -lpthread

  ./a source1.img source.img source.img target.img
