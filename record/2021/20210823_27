////////////// 20210823 //////////////
  ext2 文件系统中的很多函数都会涉及到判断宏 IN_E4EXTENTS，这个可以认为是 ext2 的扩展属性。
对应到 tptfs 中应该是在基本功能完成后的属性拓展 


////////////// 20210824 //////////////
  TptIndirTrunc 函数是一个递归调用，上层函数传递给它的 inode 是被还原的，而不是截取操作更新后的数据。
后续需要测试 inode 在函数执行完成之后数据会不会被更新。如果不能的话，那就需要利用 newblocks 手动更新


////////////// 20210825 //////////////
  编译器优化如何处理内联函数

tmpfs mount 过程：
  -> do_trap_user
    -> ecall_handler
      -> syscallenter
        -> sys_nmount
          -> vfs_donmount
            -> vfs_domount
              -> vfs_domount_first   ----------- root ------------>  vfs_cache_root
                -> tmpfs_mount                                      -> vfs_cache_root_fallback
                                                                      -> tmpfs_root

root@qemu:/ # mount -t tmpfs tmpfs tmpfs/
  tmpfs_mount----------------------------------     执行 mount 函数
  tmpfs_mem_avail----------------------------------
  tmpfs_alloc_node----------------------------------  申请 tmpfs 自定义的 node 结点(应该是根节点)  
  tmpfs_pages_check_avail----------------------------------
  tmpfs_mem_avail----------------------------------
  tmpfs_node_init----------------------------------
  tmpfs_node_init----------------------------------
  tmpfs_node_init----------------------------------
  tmpfs_node_init----------------------------------
  tmpfs_node_init----------------------------------
  tmpfs_node_init----------------------------------
  tmpfs_node_init----------------------------------
  tmpfs_node_init----------------------------------
  tmpfs_node_init----------------------------------
  tmpfs_node_init----------------------------------
  tmpfs_node_init----------------------------------
  tmpfs_node_init----------------------------------
  tmpfs_node_init----------------------------------
  tmpfs_node_init----------------------------------
  tmpfs_node_init----------------------------------
  tmpfs_node_init----------------------------------
  tmpfs_node_init----------------------------------
  tmpfs_node_init----------------------------------
  tmpfs_node_ctor----------------------------------
  tmpfs_statfs----------------------------------
  tmpfs_pages_used----------------------------------
  tmpfs_mem_avail----------------------------------
  tmpfs_root----------------------------------  执行 root 操作
  tmpfs_alloc_vp----------------------------------  申请一个新的 vnode
  tmpfs_ref_node----------------------------------
  tmpfs_free_node----------------------------------
  tmpfs_need_inactive----------------------------------   inactive 操作
  root@qemu:/ # 


tmpfs cd 过程：
  -> do_trap_user
    -> ecall_handler
      -> syscallenter
        -> sys_chdir
          -> kern_chdir
            -> namei
              -> lookup
                -> vfs_cache_root
                  -> vfs_cache_root_fallback
                    -> tmpfs_root

root@qemu:/ # cd tmpfs
  tmpfs_root----------------------------------
  tmpfs_alloc_vp----------------------------------
  tmpfs_ref_node----------------------------------
  tmpfs_free_node----------------------------------
  tmpfs_stat----------------------------------


tmpfs ls 过程：
  root@qemu:/tmpfs # ls
    tmpfs_fplookup_vexec----------------------------------
    tmpfs_stat----------------------------------  打印文件系统状态
    tmpfs_fplookup_vexec----------------------------------
    tmpfs_open----------------------------------  多次调用 open 函数
    tmpfs_getattr----------------------------------   获取文件系统属性信息    
    tmpfs_fplookup_vexec----------------------------------
    tmpfs_open----------------------------------
    tmpfs_fplookup_vexec----------------------------------
    tmpfs_open----------------------------------
    tmpfs_readdir----------------------------------   多次调用功能 readdir 函数
    tmpfs_dir_getdents----------------------------------  将尽可能多的目录项放到uio中
    tmpfs_dir_getdotdent----------------------------------  获取 . 目录项
    tmpfs_set_accessed----------------------------------
    tmpfs_dir_first----------------------------------
    tmpfs_dirent_cookie---------------------------------- 获取 .. 目录项
    tmpfs_dir_getdotdotdent----------------------------------
    tmpfs_set_accessed----------------------------------
    tmpfs_readdir----------------------------------
    tmpfs_dir_getdents----------------------------------
    tmpfs_close----------------------------------
    tmpfs_itimes----------------------------------
    tmpfs_close----------------------------------
    tmpfs_itimes----------------------------------
    tmpfs_fplookup_vexec----------------------------------
    tmpfs_open----------------------------------
    tmpfs_fplookup_vexec----------------------------------
    tmpfs_statfs----------------------------------
    tmpfs_pages_used----------------------------------
    tmpfs_mem_avail----------------------------------
    tmpfs_stat----------------------------------
    tmpfs_readdir----------------------------------
    tmpfs_dir_getdents----------------------------------
    tmpfs_dir_getdotdent----------------------------------
    tmpfs_set_accessed----------------------------------
    tmpfs_dir_first----------------------------------
    tmpfs_dirent_cookie----------------------------------
    tmpfs_dir_getdotdotdent----------------------------------
    tmpfs_set_accessed----------------------------------
    tmpfs_readdir----------------------------------
    tmpfs_dir_getdents----------------------------------
    tmpfs_close----------------------------------
    tmpfs_itimes----------------------------------
    tmpfs_close----------------------------------
    tmpfs_itimes----------------------------------

////////////// 20210826 //////////////

  文件系统在调试过程中可能会出现一些非常奇怪的错误，这种情况首先要检查代码是否符合编写模板，排除掉实现上的一些bug。
(按照现有的文件系统架构去写就可以，一般不会出现特别大的漏洞)；
  其次就是要考虑是不是有些功能函数遗漏导致的问题。因为文件系统从本人调试的过程来看，是有一套比较严格的调用机制的，
一些看起来人畜无害的函数，如果没有实现的话就会导致一些非常奇怪的问题。这个也是特别需要注意的一个点

  TptfsMount::TptVget 函数获取 inode 指针的时候，要注意加上偏移量，而不是直接指向 inode 所在块的起始位置。
因为 root inode 的索引值是2，所以前面的两个 inode entry 在块中要保留下来。之前的实现遗漏了这一点，导致 TptReadDir 
函数找不到目录项数据块


gdb 调试 kern_getdirentries 函数，调用 readdir 函数时返回错误码5:

  4145			error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, NULL,
  (gdb) n
  4147		foffset = auio.uio_offset;
  (gdb) p error
  $6 = 5


////////////// 20210827 //////////////
TptReadDir gdb 调试信息：

  (gdb) p *uio
  $2 = {
    uio_iov = 0xffffffc069ddc9d0,
    uio_iovcnt = 1,
    uio_offset = 0,
    uio_resid = 4096,
    uio_segflg = UIO_USERSPACE,
    uio_rw = UIO_READ,
    uio_td = 0xffffffc069fde680
  }


ufs readdir 调试信息：
  (gdb) p uio
  $18 = (struct uio *) 0xffffffc0a51da9e0
  (gdb) p *uio
  $19 = {
    uio_iov = 0xffffffc0a51da9d0,
    uio_iovcnt = 1,
    uio_offset = 512,
    uio_resid = 4096,
    uio_segflg = UIO_USERSPACE,
    uio_rw = UIO_READ,
    uio_td = 0xffffffc09ec5d680


  uio 每次传送的数据貌似是一整块？
  weak 函数是什么？

  即使是 C++ 编译的时候，底层还是会调用 libc 中的函数。libc 中的函数主要还是对应用户程序，一般编译内核的时候是不会用到
libc 里边的东西的。奇海系统是要将用户程序编译成内核中的线程，所以第一步就是要将 libc 链接到内核当中，这样就用户线程就可以
正常编译执行。
  完成上述过程会遇到一个问题，就是 libc 中的函数跟内核函数有重名的，这就会导致链接的时候会出现问题。当前的做法是将内核函数
都加上前缀。因为如果该 libc 的话，应用程序都要进行相应的更改，这样就会很麻烦。并且后续我们可能还需要添加新的第三方库，不可能
把这些都给改掉的。所以最好的方式还是直接把内核中的函数和一些全局变量名给改掉


  TptReadDir----------------------------------222
  TptReadDir: TptBlkAtOff error is 0,!----------000
  
  TptReadDir: while---------------
  dp->tptd_reclen is 256
  a is 7
  TptReadDir: --------888
  TptReadDir: --------999
  TptReadDir: dstdp.d_reclen is 32

  TptReadDir: while---------------
  dp->tptd_reclen is 0
  a is 7
  TptReadDir: error EIO!----------111

  TptReadDir----------------------------------333
  TptReadDir----------------------------------555
  TptReadDir----------------------------------end

  第二次 while 循环中的目录项数据有问题，tptd_length 应该是 256，但是读出来却是0，需要用gdb调试一下

  错误是发生在 TptFsinit 的过程中，对类成员 pDir 赋值的时候没有把它的类型变为 char*，而仍然是 struct tpt_dir* 类型。
所以，pDir + DIRSIZE 的话跳转的距离是 sizeof(struct tpt_dir) * DIRSIZE，而不是 DIRSIZE，要注意


在 tpt 目录下执行完 ls 命令之后没有目录项显示：
  文件系统在 readdir 操作之后，会返回 kern_getdirentries 函数当中，这里应该是解析 uio 中获取到的数据。下一步要重点关注
uio 中包含的数据在上层操作中是如何被解析的