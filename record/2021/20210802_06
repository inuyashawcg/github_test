////////////// 20210802 //////////////
  在设计 tptfs 类的时候，可以利用 vscode Ctrl+k Ctrl+0 和 Ctrl+k Ctrl+j 将所有的函数进行展开和折叠。
其中一些表明 static 的函数，如果不是用来进行注册的，其实就可以作为类的私有函数

  在 ext2 文件系统中，貌似还有通过数据 offset(in-bytes)来计算其在文件系统中的逻辑块号的，参考宏 lblkno。
为什么要计算逻辑块号呢？很显然是为了通过这个逻辑块号计算数据在磁盘中储存的位置，然后调用read函数将数据读取出来
放到buffer当中。这是在FreeBSD中的操作流程
  奇海需要增加一个宏，用来将相对于文件系统的(而不是某个数据区块的)逻辑块号(其实就是相对虚拟页号)转换成虚拟页起始地址。
感觉可以定义一个 void* 来指向这个地址，然后再做强制类型转换

  ext2 中磁盘数据块对于目录项的存储方式参考github版本代码注释

////////////// 20210803 //////////////
  htree 中的一些结构体涉及到了 struct buf，一些函数逻辑就是通过 bread 函数将数据读取到内存当中，然后利用buf管理起来。
该结构体中有一个 data 字段，指向分配的内存区域。这个buf貌似跟物理页存在某些关联，所以设计中最好不要使用这个结构体。如果
现有设计中存在，则需要考虑将其移除

  从 ext2 代码逻辑中可以看到，文件系统有一套完整的 checksum 机制用来验证数据的正确性。主要针对超级块、位图、目录块、
块组等等数据进行计算和验证。tptfs 当前应该还不需要考虑这些(最基本的功能都还没有实现。。)

  关于 ext2 中 bread 函数的理解。之前错误的认为 bread 函数中的 lblk(logical block number) 参数表示就是磁盘块号，
其实它表示的是 file/device 的逻辑块号。我们文件在磁盘上存储的块并不是连续的，但是我们计算数据在文件中的相对块号的时候，
其实是把它看作是连续的。函数参数传入的就是这个我们计算出的相对块号，那就需要再做一步转化，将其转化成具体的磁盘的块号。
  tptfs 应该是需要重写这个函数，把磁盘块的计算转换成虚拟页号的计算。vfs 会提供一个函数注册接口 .vop_bmap，它会有一个
标准的传参结构体。里面有些字段在 tptfs 中其实是不需要的。感觉调用的时候可以置空，应该影响不大

  tptfs 中新增了一个将逻辑块号转换成虚拟页号的一个宏定义，要改一下注释。不是计算文件系统的逻辑块，而是文件的逻辑块号
  TptBlkAtOff 函数要改掉，需要先调用 bmap 函数将文件逻辑块号转换成具体的虚拟页号

  btrfs：Linux新一代文件系统


////////////// 20210804 //////////////
  ext2 文件系统对文件/设备数据块寻址的时候，首先我们要确定文件数据块是在索引数组的几级索引当中。如果是在直接块索引，那就可以
一步找到数据对应的磁盘块号。所以 bmap 函数所要做的第一件事就是确定需要查找 inode 索引数组的哪个元素；确定了这个之后，在一步
步向下查找，知道获得文件块所对应的磁盘块

  ext2 bmap 函数的一个最重要的步骤就是 map array 的生成。这个数组中的元素保存的貌似是用来保存间接寻址的结点的信息。我们通过
遍历这个数据，就可以得到最终的数据所在的磁盘块。类比 tptfs，我们就可以将磁盘块转换成虚拟页号，然后直接计算出数据所在的虚拟地址


////////////// 20210805 //////////////
  ext2 HTree 并不是传统意义上的 BTree，它是另外一种数据结构。它的主要作用就是对文件系统的目录项进行索引。可以参考：
    https://www.usenix.org/legacy/publications/library/proceedings/als01/full_papers/phillips/phillips_html/index.html
  
  htree 跟 Btree 的性能比较类似，但是 htree 的实现更为简单，而 ext2 的设计原则就是简单化，所以最终采用了 HTree


////////////// 20210806 //////////////
  在做好自己的本职工作的同时，一定要多多去了解组员和其他组所做的工作，建立起整体概念。这一点一定要注意，要不然很可能以后都没有办法
跟别人一起讨论问题了。目前对于刘强(进程和线程调度)方面的工作了解不足，需要补充相关知识。而且对于 ELF 文件的加载认识还不到位，需要
进一步深化。
  https://blog.csdn.net/douyuhua0918/article/details/7458845
  一般我们认为 main 是程序的入口函数，其实并不是这样。在 main 函数执行之前，会调用 glibc 中一些初始化和构造函数进行一些操作。比如将全局变量
和静态变量初始化。等这些初始化操作都执行完了之后，才开始执行 main 函数。可以参考 /share/rd/docs/linker_loader 下的文档

C++虚函数表：
  https://blog.csdn.net/haoel/article/details/1948051/

C++ new 运算符实际执行了三个步骤：
  1、new表达式调用名为 operator new / operator new [] 的标准库函数，该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的
    对象(本质上就是malloc)
  2、*编译器*运行相应的构造函数以构造这些对象，并传入初始值
  3、对象被分配了空间并构造完成，返回一个指向该对象的指针

  即使在标准库中已经定义了这些函数，我们仍然能够定义自己的版本。编译器不会对这种重复的定义提出异议，反而将会使用我们自己定义的版本替换标准库版本；
  我们既可以在全局作用域中定义该函数，也可以将它们定义为成员函数
  所以，在奇海操作系统中，我们其实是可以有两种方式来设计 new 操作符的。一种就是全局操作符，所有对象都调用这个；另外一种是在作为类的成员函数