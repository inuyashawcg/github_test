////////////// 20211129 //////////////
  二叉或者多叉树的核心思想其实就是二分法，它的数据结构设计和操作(比如旋转)其实都是为了更加高效的实现二分查找。
但是树的旋转开销其实是不小的，比如目录文件再执行拷贝的时候，最坏的情况可能会导致相当多节点的 split。这其实又
会导致另外一个问题，我们维护目录树的时候要经常进行目录树旋转操作，也就是说需要花费相当多的时间去维护整个树的
平衡状态

  实际统计一下奇海系统的目录结构可以看到，大多数目录下的文件数是非常小的，一般不超过20个文件。文件位置深度不大，
3-6层之间的文件层数居多。所以，当我们需要查找一个文件的时候，平均最坏情况就是上层目录都包含有20个文件，并且我们
所要查找的文件刚好位于最后一个，并且这个文件的目录深度又是6，那么就需要查找120次。即使我们采用的是单链表结构，
对于操作系统而言，执行120次查找还是相当快的

  实现过程中还可以进行一些优化，比如采用双向有序链表，这其实就跟树有很高的相似性了。可以利用每个文件的文件名计算
对应的 hash，然后按照大小排序，得到一个有序链表。查找的时候就可以采用二分查找的方式，跟搜索树基本上就是一样的了。
相比于普通链表，在执行节点插入操作时会多一些开销

  tptfs 文件查找应该也是非常快速的，首先所有的目录项都是相同大小，遍历只需要指针固定跳转。htree 机制，数据块定位
也比较快速。从目前的文件分布看，一个数据块就能包含有绝大多数目录的子节点数据，都不会触发 htree 构造。所以，到底两者
谁更快其实目前还不好判断


  struct mount->mnt_rootnode 成员在 ext2fs/tptfs 中貌似一直是空的？ TptRoot 函数其实就是为了获取文件系统
根节点对应的 vnode (通过调用 TptVget 函数)，正常逻辑是 vnode 分配的时候就应该和某一个文件树节点建立映射关系

  FileNode 结构中应该不用包括 vnode 和 file 结构体，因为它们两个都是动态生成的，并且可能存在多个进程同时访问一个
文件的情况，那此时就是多个 file 和 vnode 对应一个 inode。如果 FileNode 包含这两个结构体的话很会有冲突。所以，采用
的方式就是 vnode 添加一个指针指向 FileNode，而 FileNode 只包含一个指向 inode 的指针。当它需要访问对应的 vnode 时，
通过 inode 中的成员间接访问，这样就可以衔接原有机制，避免冲突的出现

  vfs 层级的 lookup 函数执行的是无差别的路径查找，也就是说它不管底层是哪种类型的文件系统，只是对路径进行解析。由于目前
tptfs 还无法作为根文件系统，所以只能依附于 UFS，那在 vfs 层级是不能进行修改的，否则将导致其他文件系统无法正常使用。所以
暂时还是先修改 tptfs 本身的 lookup 函数

  struct mount -> mnt_vnodecovered 表示的是挂载点对应的原文件系统中的分配的 vnode，貌似是只会分配这一个，而不会在
新的文件系统挂载的时候再次分配。挂载之后 vnode -> v_mountedhere 会填充新的文件系统的 struct mount，而且在 lookup
的时候也会对这个成员进行判断。所以挂载替换的机制就是利用原有的文件系统分配的 vnode，挂载的话就把对应字段填充，当访问到该
节点的时候判断该字段是否空。如果不为空，则接着执行 vget 函数获取新的 vnode，并将其更新到进程文件描述符当中。所以当进程
访问到该节点下的文件的时候，机会直接跳转到对应文件系统中进行执行


////////////// 20211130 //////////////
  文件树的构造还需要考虑目录项的存储。在现有机制中，对于文件的查找会遍历目录的数据块，每个数据块都是有若干 slot 组成的。
查找过程中会更新 inode 中关于 slot 的相关数据。考虑是否将文件对应的 slot 的地址也存放到树节点当中

  vfs 层级 lookup 函数会将把文件的路径信息拆分成单独的组件，然后为每一个组件分配对应的 vnode 和 inode。inode 的获取是
通过对应文件系统的注册函数 vfs_vget 实现的(利用文件系统的 lookup 函数找到目录项中存放的 inode number 得到一个 inode)。
这个过程可以利用文件树进行替代

  syscall 将文件路径信息传递过来之后，仍然是拆分成独立组件。如果是在 tptfs 下，则直接跳转到文件树进行查找，每个组件对应一对
inode-vnode。如果该路径存在，就一直处理下去；如果不存在，感觉还是要回归到原有的查找函数，创建一个新的目录项


////////////// 20211202 //////////////
  tptfs 当前目录项是通过线性或者 hash tree 的方式存放在数据块当中。当我们需要搜索的时候，需要在数据块中不断遍历，查找对应的
文件的目录项描述。但是这会带来一个问题，就是如果我们以后要利用文件树来查找，就不会再去遍历目录文件数据块，所以这些数据块就没有
存在的必要了，可以将它们包含的数据整体搬运到 FileNode 类当中。文件系统内部保留目录文件的 inode，只不过不会再分配数据块



////////////// 周会总结 //////////////
  奇海操作系统目前需要关注三个方面的专利：
    - 内存文件系统
    - 单一地址空间
    - 进程隔离
  目前先调研国内的一些，以后有需要再去看国外的

  需要了解编译器编译C++代码的过程中将类的信息放到了哪里。貌似编译器会将某个类的信息包装到一个特定的数据结构当中，这样调试器才能准确
打印类的成员信息