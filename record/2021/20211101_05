////////////// 20211102 //////////////
  FreeBSD 中为超级块和 struct mount 中都包含有 flag 用于记录文件系统本身的一些属性，其中就包含有对扩展属性(ACL)是否
支持的标志。tptfs 中直接设置为全部支持这些特性，所以 flag 中的这些设置选项都是默认打开的，否则就会提示(ACL为例)：

  setfacl: project/: acl_get_file() failed: Operation not supported

  按照字节对齐原则重新排列 struct tpt_inode 中成员的位置，可以省出16个字节的存储空间，刚好可以增加两项直接索引数组元素。
由于 tptfs 完全舍弃了 checksum 检查机制，所以该结构体中预留的 checksum 字段被移除，总体大小仍然是 256 字节

////////////// 20211104 //////////////
  tptfs 对于文件的操作应该不能直接在 global registery 中放置 inode。GR 中存放的应该是类，而不能是简单的数据结构。目前
进程对于文件的操作是通过文件描述符结构来实现的，其中会包含一个 struct file 的一个链表，所有进程会打开的文件都会在该链表中
创建一个 file 结构。FreeBSD 跟 Linux 都是进程来管理整个文件描述符，每个进程都有自己的文件描述符，假设调用 fopen 的时候
返回的 fd 即使是相同的，它们所代表的文件大概率也是不相同的。
  但是奇海系统把原有系统中的进程改变成了线程，所以对于文件描述符来说，就是所有的线程都共享一个文件描述符表，需要重新设计新的
进程访问文件机制

  二叉搜索树的递归版本使用了系统运行时栈，非递归版本则运用了用户自己维护的栈。由此可以看出，二叉搜索树基本的遍历通常都是利用
栈来实现的。但是两种方式的效率都不是特别好，因此要考虑不使用栈来实现遍历


////////////// 20211105 //////////////
  通过 vfs 代码可以发现，sys_open 函数执行过程中会调用到 namei 和 lookup 函数，这两个函数执行完成之后，会把路径名转换成
一个对应到文件的 vnode 结构体，然后把 file operations 填充为全局 vnops。
  tptfs 中要把文件搜索放到 global registery 当中，所以可以考虑重构 namei 和 lookup 函数，输入和输出保持原样，只把搜索
的过程从 namecache 和 VOP_LOOKUP 中转移到搜索文件树


////////////// 周会记录 //////////////
  操作系统应该是一个静态的，而不是动态的。就是说操作系统要执行某个功能函数的时候，绝对不能花时间去找，而应该是直接拿到。所以
奇海操作系统中的 syscall 或者一些全局函数之类的，就直接给它编译到一个 table 当中，用到的时候直接利用索引拿到对应的地址即可。
  树或者链表一类的数据结构只能用来管理一些动态的对象，比如文件等，这些对象系统并不知道它们是否存在，或是在系统运行过程中会动态
生成。
  算法和功能模块一定要再三验证之后才能合并到操作系统当中，而且要设计一套测试机制来证明功能的正确性

  调试的时候要在模拟器和真是机器上都进行调试，因为出现过在模拟器上能够正确运行，但是一放到真实机器上就出错

  googletest 要用 pthread，奇海可能会不能使用了
  
  qemu 搭建一个 riscv 版本和 X86_64 版本运行速度可能不一样。有一些工作是平台相关的，比如上下文切换要用到不同架构的特有的
寄存器，这种就必须要利用模拟 riscv 版本，其他非平台相关就可以直接在 X86_64 上来测试