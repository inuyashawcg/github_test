////////////// 20210809 //////////////
  HTree 的根节点是目录文件的第一个块，叶节点表示的是普通的目录数据块，中间的节点用于查找？
  Htree通过 hash 值作为 键值，而不是用名称。每个键值引用的也不是单个目录项，而是包含一组目录项的数据块

  以前一直以为 htree 中的数据都是在内存当中，在系统启动之后开始构建。但是从 htree 文档中的表述来看，htree 中的数据很可能还需要
在磁盘中划出一些磁盘块来进行持久化存储。这一点需要进一步确认

  奇海newtpt工具的执行流程可能需要修改一下，目前采用的方式是直接将目录项信息写入，但是没有 htree 的相关信息。但是在 htree 代码中
我们可以看到，htree root 节点的属性信息是通过读取逻辑块0到缓存来获取的。所以，newtpt 是否需要补充上这些数据呢？ 扩展一下，其他的
数据块是不是也需要做某些相应的处理呢？


////////////// 20210810 //////////////
ext2 ext2_htree_find_leaf() 函数中包含了一步操作:

  entp = (struct ext2fs_htree_entry *)(((char *)&rootp->h_info) +
	    rootp->h_info.h_info_len);

  其中 rootp 是指向 buf->data 成员的一个指针，data 中是存放的是 inode 对应文件的0逻辑块中读取的数据。所以磁盘存放目录项的数据块
很可能不仅仅包含目录项的数据，而且有可能包含有一些其他的管理数据。比如这里涉及到的 h_info 成员，它其实是一个 ext2fs_htree_root_info
结构，位于 ./ ../ 两个目录项数据后面，占用8个字节

  ext 文件系统目前所了解到的，对于目录项的处理分成两种方式。第一种方式是线性查找，Linear (Classic) Directories。目录项在磁盘中的存储
应该就是书籍或者文档中介绍的那种最基本的方式。缺点主要就是当文件系统的规模越来越大时，查找效率会降低；针对上述情况，ext文件系统引入了
一种新的方式，Hash Tree Directories。它利用 hash tree(htree) 组织和查找目录项，即使在较大规模的文件系统仍然具备较好的性能。
  未来奇海操作系统的内存和磁盘都将远大于目前设计，所以文件系统必须能够适应这种变化。所以一定是要采用这种方式来管理目录项


////////////// 20210811 //////////////
uio其实是可以跨越 user space / kernel space 进行数据传输的。它的行为其实受限于两个宏定义:
  UIO_USERSPACE: 
    该模式下 uiomove 函数会调用 copyout / copyin 函数进行数据传输
  UIO_SYSSPACE:
    该模式下 uiomove 函数会调用 bcopy 函数进行内存对内存的数据拷贝
以后奇海系统不再具有用户控件和内核空间之分，全部划归内核空间。所以这些函数的实现就需要做相应的修改

ext2 文件系统中，ext2_blkatoff 调用频率比较高，其中会用到 struct buf(文件系统缓存机制)。tptfs 中是要把缓存删减掉，直接操作虚拟内存。
目前来看需要保留的两个字段，一个字段作为数据指针，另外一个要保存虚拟页号(对应 ext2 中的磁盘块号)。所以，可以暂时设计一个简单的结构体
用来替代 buf，其他的信息如果有需要可以再添加

////////////// 20210812 //////////////
  vfs namecache 目前看来可以是直接继承就可以的，它的功能应该就是把从磁盘中读取出的目录或者文件的名称保存在内存，下一次再次读取的时候
直接在内存中查找即可。tptfs 相当于是把从持久化内存中的数据读取到非持久化内存中

  文件系统中 uio 用处比较多的应该就是应用程序想要访问一个目录项中的内容时，应该是会调用 readdir 这些函数。目前还是需要将数据从内核空间
发送到用户空间的，新的机制也还没有完成，所以可以暂时保留 uio

////////////// 20210813 //////////////
  调研一下编译器是否感知哪些文件是否已将存在，然后编译的时候直接修改 fopen 等函数的行为。编译器就需要知道已有的文件都有哪些，要放到哪一个
具体的虚拟地址空间。实现的话就需要几个必要的条件:
  1、编译器要知道有哪些文件存在
  2、要能够区分不同路径下的同名文件(global registry?)
  3、所能做的改变应该就是把原有的路径查找直接编程指向某个地址(因为当前文件是直接对应inode，可能采取的做法就是 fopen 直接指向具体 inode 的
     地址。但是 inode 的分配其实也是动态的，所以它的虚拟地址其实也不是固定的。所以，对于一些编译完成后就不会再去改变的文件，可以考虑采用这种
     方式处理
  4、编译器执行完编译操作之后，除了一些需要动态链接的地址，其他都已经是固定下来了，大致上可以认为是一个静态的。但是文件关联其实需要经过操作
     系统完成查找的动态的一个过程，所以我们就需要在动态和静态之间搭建一个"桥梁"，用一个静态的东西去管理动态的内容，inode table 目前来看算是
     比较合适的一个选项。
     inode table 在虚拟地址空间的位置是相对固定的，如果我们在构建类似根文件系统的阶段把这些文件做一些特殊处理(在 inode table 中顺序排布)，
     其实是可以得到每个 inode 的固定的虚拟地址的。所以，整体上可能要分成两个部分，编译器对应 inode table 固定地址处理的部分; 操作系统实现
     对文件内容的查找