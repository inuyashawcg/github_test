////////////// 20210830 //////////////

  TptReadDir 调试过程中发现，一些在磁盘文件系统中需要加锁的地方，在内存文件系统中添加可能会导致错误发生。
比如 vop_stat 和 vop_close 函数中，ufs 和 ext2 会对 vnode 进行加锁操作用来更新时间字段；在 tmpfs 中
则是直接更改相关字段，无需加锁。

  所以，要关注一下 vnode 等结构体中的锁的具体作用是什么。如上述所说，可能 vnode 的锁操作是需要在磁盘读写操作
的时候才会被用到，而如果数据已经在内存中的话，就没必要再加锁。tmpfs 所有的数据都是在内存中，所以不用加锁。也有
可能是函数实现中对锁的使用方式存在问题，还是要调查一下真正的原因是什么

  挂载 tptfs 之后，执行 ls -al 命令，打印信息会出现两种：

    total 5
    ls: ./.: No error: 0
    drwxr-xr-x   2 root  wheel  512 Aug 30 03:03 .
    drwxr-xr-x  21 root  wheel  512 Aug 30 03:04 ..

    total 5
    drwxr-xr-x   2 root  wheel  512 Aug 30 03:03 .
    drwxr-xr-x  21 root  wheel  512 Aug 30 03:04 ..


  htree 中的 root node 和 node 的设计要参考目录项结构体的设计，因为其中包括了一个 fake_dirent 结构体，它就是
用来模拟目录项结构的。这就要求我们需要把两者的字段一一对应起来，否者赋值或解析的时候会出现错误，这一点要特别注意
  .. 目录的大小是除去第一个目录项之后的剩余空间的大小，初始化的时候也要注意


TptfsMount::MkfsMakedir 返回值
  线性查找的时候，我们所要读取的数据只有 . 和 .. 两个目录项的内容，所以返回值(也就是 tpti_size)就只有两个目录项的大小，也就是 256 bytes；
当我们切换到 hash tree 查找的时候，inode 的大小就不仅仅是两个目录项，还会包含 root_info，htree_entry 等等，这些数据的大小刚好是一个数据块
的大小。所以返回值应该是一整个数据块的大小，也就是 4096 bytes

TptfsVnode::TptReclaim
  在 ext2 中，该函数会有一个 free inode 的一个操作，这是因为磁盘文件系统中磁盘跟内存中的 inode 其实是不一样的，我们需要通过 malloc 函数
为内存中的 inode 分配存储空间，然后通过文件系统内部函数与磁盘上的 inode 建立映射关系。

  tptfs 中所有的 inode 其实都是在内存当中，我们访问一个 inode 直接指向其所在的虚拟地址即可，所以是不需要 malloc 的，也就不存在 free 操作


////////////// 20210831 //////////////
  ext2_htree_has_idx (TptHtreeHasIdx) 函数需要判断文件系统是否要具备 hash index 的属性。也就是说如果我们想要利用目录项的 hash 查找，
就必须要设置该属性到超级块当中，所以在 tptfs 初始化过程中需要增加一步操作

  将 vnode operations 中的打印信息输出出来可以看到，touch 命令会调用 vop_create 函数创建一个新的文件，所以要把相应的函数补全


////////////// 20210901 //////////////
  ext2_lookup 函数可以大体上划分为两个步骤。第一步就是判断文件系统是否支持 hash index，如果支持的话就采用 hash 搜索。如果出现了错误，或者
文件系统不支持 hash，那么就采用线性查找的方式；第二步就是判断所要进行的操作的类型，是查找、创建、重命名，还是别的操作，然后根据不同的操作类型
调用不同的功能函数

////////////// 20210902 //////////////
  goto 后面如果声明变量的话，会提示：
    cannot jump from this goto statement to its label
  研究一下为什么会这样

////////////// 20210903 //////////////
  htree 对于数据碎片化的实际测试做的不够，目前还不太能确定运行时的碎片化程度。防止这种情形出现的方法就是尽可能的将释放掉的数据块进行合并。类似于
线性查找的合并方式，将那块区域添加到上层目录项当中

  从 htree 的功能函数实现来看，当我们执行添加或者查找的时候，都是要首先获取 root node 的信息。所以，tptfs 中就是读取 data blocks 的第一个块

  重点关注 ext2_htree_create_index 函数的实现逻辑，它的作用就是把一个线性查找的目录项数据块转换成一个 hash 查找的目录项数据块。其实根本不用手动
进行操作，作者已经帮我们实现了这个功能

  