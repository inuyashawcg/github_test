////////////// 20210726 //////////////
1、通过 gdb 调试发现，当我们参考 devfs 文件系统的挂载方式挂载 tptfs 的时候，不能执行
  set_rootvnode 函数，因为它里边会对进程的 fd 相关属性进行设置。这样会导致 start_init
  函数执行时的路径搜索产生问题。正常情况下应该是走 /dev 路径，执行完以后改变成了 /tpt 路径。
  但是这个路径下是没有任何数据的，就会提示 /sbin/init 等初始化操作找不到路径的错误信息：

    tptfs_magic is 8224
    kern_symlinkat(tptfs) returns 20
    TptfsMount::MountRootTptfs----111
    start_init: trying /sbin/init
    exec /sbin/init: error 20
    start_init: trying /sbin/oinit
    exec /sbin/oinit: error 20
    start_init: trying /sbin/init.bak
    exec /sbin/init.bak: error 20
    start_init: trying /rescue/init
    exec /rescue/init: error 20
    init: not found in path /sbin/init:/sbin/oinit:/sbin/init.bak:/rescue/init
    panic: no init
  
  目前可行的方式是参考 tmpfs 的方式来做，里边有一个 vfs_mountedfrom 这个函数感觉应该是必须要
  有的。因为内存文件它不会去对应 /dev 下的设备文件，所以我们在执行 mount 命令的时候是不需要指定
  from 路径。这个函数中会指定我们挂载的文件系统为 ***fs，可能就是为了避免指定设备文件的参数

2、在代码设计之初要多花时间考虑如何把代码设计的简洁、好维护。针对 tptfs_mount 函数的一些代码逻辑，
  提出一些修改的意见。在 vget 函数执行的时候，会利用 mount/vnode 结构体对 inode 结构体进行初始
  化操作。这里感觉可以把该功能独立封装成一个函数。因为以后 vnode 或者 inode 的结构体设计可能会有
  改变，初始化方式就需要跟着修改。如果代码不单独拿出来，以后可能要修改很多 inode 初始化的代码。独立
  出来就只需要修改这一个函数的实现逻辑即可。


////////////// 20210727 //////////////
  持久化内存中操作的虚拟页号都是相对页号，即我们定义持久化内存起始虚拟地址，页号计算就是用实际虚拟地址
减去起始虚拟地址 / 4k。所以 tptfs 中虚拟地址的计算方式也要做相应的调整

  inode 编号是从1开始，而不是从0开始；
  在 ext2 文件系统中，EXT2_BADBLKINO = 1 表示的是一个无效的 inode

将 riscv.img 文件以 ufs 的形式挂载之后可以看到，其中是包含有 /dev 目录的，不过里边没有任何文件。
也就是说，/dev 目录并不是在 mountroot 的时候创建的，而是在根文件系统中本身就包含有的。所以可以
推测系统应该是先挂载 devfs，找到磁盘设备文件，然后根据 /sbin/init 等路径进行初始化操作。再查找
磁盘设备文件，挂载 ufs，整个系统就算启动起来了。

如果 tptfs 想要模仿 devfs，目前来看还是要在根文件系统中提前创建 /tpt 目录。所以现在还是以常用文件
系统的挂载方式来操作比较合适


////////////// 20210728 //////////////
  PersistentMemory.cpp 文件中包含有一个持久化内存全局变量 persistentMemory，类成员 Snapshot* 
_pSnapshot 用于将虚拟页和磁盘块之间建立映射。当我们对内存页进行修改后，就可以利用其 setLbn 函数对
索引数组进行赋值。下次启动的时候，如果执行正常，磁盘上的数据就可以得到及时更新

  对于目录项设计可能要进行修改。ext2 等磁盘文件系统对于目录项的存储是变长的，长度是4的倍数。而在内存中
的 struct dir 包含有一个 char name[255]，它占有的内存已经是达到了255个字节。所以无论在磁盘中目录项
的名字是多长(最大不超过255)，到了内存当中之后就是占255字节，其他没有用到的就直接填充。
  
tptfs 对于目录项结构体的设计可以考虑两种方式：
  1、将 name 数据的长度缩短，其他字段保留，长度固定到 256 个字节。也就是每个数据页可以存放16个目录项
  2、将 name 指定为128字节，其他的字段任然保留，剩余字段用于未来扩展使用

tptfs 与内存持久化交互机制：
  1、内存持久化每次都会读取超级块的数据。超级块数据是在磁盘的固定位置存放的，而其他的数据则是随机存放的
  2、内存持久化会建立一个类似 hash 数组的一个结构来存放 virtual memory page 与磁盘数据块的对应关系
  3、通过 snapshot(由一个独立的线程来处理)机制，每次将持久化内存中修改过的页的数据按照对应关系写回到磁盘
    当中
  
  基于上述分析，tptfs 测试应该就是读写对应的虚拟页，然后重启，再次读取相同的虚拟页，数据应该是已经刷新的过的。
  但是目前没有刷新，可能持久化机制这块还存在一些问题。

  MkfsMakedir 函数在下面版本中打断点之后无法进入：
    commit 92b7492a536a00fd09131070f67efeae3fe8742f (HEAD -> user/wcg, origin/user/wcg)
    Author: chenguang.wang <chenguang.wang@terapines.com>
    Date:   Tue Jul 27 17:08:01 2021 +0800

        Add source code to test tptfs initialization function


  在打印两个目录项的时候，如果在 gdb 中直接获取地址，然后加 256，发现打印的数据是错误的；但是如果在代码中添加
  上述逻辑源码，发现打印的数据就是正确的，很玄学；

  C语言对于字符数组的赋值问题要考虑一下，例如： char name[255] = "." 这样是会报错的，"." 属于是一个常量，这样
  操作总感觉怪怪的。参考一个博客中的解释：

    定义一个数组char a[10];
    怎么给这个数组赋值呢？
    1. 定义的时候直接用字符串赋值
    char a[10]="hello";  正确
    【注】：不能先定义再给它赋值，如char a[10]; a[10]="hello"; 这样是错误的！
    2. 对数组中字符逐个赋值
    char a[10]={'h','e','l','l','o'};
    3. 利用strcpy
    char a[10];

    strcpy(a, "hello");

    易错情况：
    1. char a[10]; a[10]="hello";//一个字符怎么能容纳一个字符串？况且a[10]也是不存在的！
    2. char a[10]; a="hello";//这种情况容易出现，a虽然是指针，但是它已经指向在堆栈中分配的10个字符空间，
      现在这个情况a又指向数据区中的hello常量，这里的指针a出现混乱，不允许！


////////////// 20210729 //////////////
  在文件系统 vfsops 中一般都会包含有一个 statfs 相关函数。通过 gdb 测试可以看到，这个结构体使用来描述文件系统的
基本信息的。比如说文件系统扇区大小等等(我们利用 df 命令查看操作系统的所有文件系统类型的时候貌似会解析 statfs 结构体)。

  mount 其实可以理解为是一种“替换”，也就是说本来这个目录是A文件系统下的一个目录，所以它所支持的操作都是A提供给它的。
但是如果一旦我们把文件系统B挂载到该目录下，它其实就开始支持B所提供的一些操作。struct mount 中包含有 optnew 和 mnt_opt，
这两个操作链表大概率就是表示原有文件系统的操作和新挂载文件系统的操作

  测试：
    在一个目录项创建新的文件和目录，然后mount，发现新创建的这些都被屏蔽掉了，里面只剩下 . 和 .. 两个目录。说明该目录指向的
  inode 被替换掉了。等执行完 umount ，里面的文件又重新恢复，说明 inode 回退到了之前的状态

fs_root 这个函数其实是必不可少的。devfs 跟其他文件系统的差别主要是它不会采用手动执行 mount 命令这种方式来挂载文件系统，而是
在 vfs_mountroot 执行的时候直接挂载。所以它需要自主创建 struct mount，而一般的文件系统都是可以利用 mount 指令来实现，这个
过程就会创建对应的 struct mount；然后就是一些函数的执行顺序会发生变化，比如上面提到的 **fs_root 函数，devfs 是在挂载阶段执行，
而其他文件系统则是利用 vfs 的机制来执行的，所以该步骤不能省略

  不管是磁盘还是内存文件系统，一般都会有一个 ***fs_reclaim 函数。这个函数在 ext2 文件系统当中是用于回收 inode 来使用的。因为
当我们挂载或者创建文件的时候，都会为 vnode malloc 出一个 inode (in memory)的结构体，对应于磁盘中存储的 inode(ext2 中包含有
对应的转换函数)。当文件被删除的时候可能就会将其中的一些数据清空，或者直接更新(因为只要标记某些块未被使用，即使它里边有数据，也是可以
被覆盖的)。
  inode 数据感觉只要被初始化了之后，应该是不会被删除的，只要更新一下就好，尤其是磁盘中的。要不然重复清零再回写就很浪费时间。

  文件系统会关联很多关于 vfsopt 和 vnopt 的函数。当我们基于现有文件系统创建新的文件系统的时候，要首先将这些函数进行空填充，顺便加入
打印信息。这样我们在执行一些指令的时候就可以看到调用了哪些函数

////////////// 20210730 //////////////
  C++中一个类调用另外一个类的静态成员函数是不需要实例化类对象的

  FreeBSD 编译过程中出现ld: undefined symbol 的时候，首先要考虑一下是否在 riscv/files 配置文件中添加了新增的.cpp文件；或者是
头文件的包含是否除了问题

  目前很多读取磁盘的操作直接改成了读取虚拟页，需要加锁保护吗？

  