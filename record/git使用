//////////////////////////// 基本认识 ////////////////////////////
git 是分成工作区、暂存区和版本库三个部分，reset 命令它是用来重置暂存区的，而不是工作区的。restore 用于重置暂存区：
  - git add 之后会把工作区的修改更新到暂存区，如果此时突然发现这些修改没必要添加到暂存区，使用 reset
  - 当发现文件本身并不需要修改时，使用 restore 命令，将工作区也进行重置，这样文件就重新回到了修改之前的状态

.gitignore
  - 我们可以在.gitignore文件中添加条目忽略某个目录或者文件。假如我们就添加一个 dir，所有包含这一名字的目录都会被忽略。
    为了防止这种事情的发生，我们最好还是添加完整路径
  - 要养成以获取git仓库就创建 .gitignore 文件的习惯，防止提交一些没有用处的文件


- git diff 可以使用一些界面工具来进行代码差异对比：
    git difftool
    使用下面的命令查看 git 支持哪些界面化工具：
      git difftool --tool-help

- git 可以设置自己习惯使用的编辑器：
    git config --global core.editor

- git rm 和 rm 的区别是什么？
    用 git rm 来删除文件，同时还会将这个删除操作记录下来；
    用 rm 来删除文件，仅仅是删除了物理文件，没有将其从 git 的记录中剔除。

    直观的来讲，git rm 删除过的文件，执行 git commit -m "abc" 提交时，会自动将删除该文件的操作提交上去。
    而用 rm 命令直接删除的文件，单纯执行 git commit -m "abc" 提交时，则不会将删除该文件的操作提交上去，需要在执行commit的时候，多加一个-a参数，
    即rm删除后，需要使用git commit -am "abc"提交才会将删除文件的操作提交上去。

    比如：
    1）删除文件test.file
    # git rm test.file
    # git commit -m "delete test.file"
    # git push
    或者
    # rm test.file
    # git commit -am "delete test.file"
    # git push

    2）删除目录work
    # git rm work -r -f
    # git commit -m "delete work"
    # git push
  
- git merge 和 git rebase 应用场景解析：
    https://www.cnblogs.com/marblemm/p/7161614.html

- git merge 或者 git rebase 发生冲突并且手动解决之后，需要再执行一步 git add 命令告诉 git 冲突点
    已经被解决了，然后在手动提交或者执行 git rebase --continue，这个时候才算是真正完成了代码提交

- 当我们需要维护一个长期项目的时候，最好建立不同稳定等级的代码分支。只有当一个分支中的功能足够稳定之后，
    才能向更高稳定等级的分支中进行合并。虽然这么做并不是必须的，但是当我们的代码足够庞大且复杂的时候，
    我们就会体会到这种管理方式带给我们的便利

- 当两个开发这同时向一个项目中提交的时候，后来提交者可能会被 git 要求首先要将已经提交的内容在本地进行合并，
    然后再进行提交。即使是两个开发这修改的并不是同一个文件时也是如此


//////////////////////////// 使用场景 ////////////////////////////
场景1： 加入代码开发到某个阶段，发现方向有错误，然后想退回到某个提交之前重新开发

首先要将现有的一些没有提交的修改进行保存，不一定非要提交，这样做是为了保证当前代码分支是干净的。可以先执行
  git stash
就是将没有提交的代码暂时保存起来。然后我们就可以执行
  git reset --hard ***
将代码回退到某个分支。这里要注意的是，当我们执行了 git push 之后，我们所有的工作都已经同步到了远程分支当中。
所以我们无论如何操作当前代码分支，甚至是直接删除了所有代码，只要远程分支没有发生变化，我们还是可以直接 git pull
下来最新修改的代码。
回退之后就可以基于当前版本创建新的分支，完成之后就可以切回原来的代码分支恢复现场，这样就可以在新的代码分支中在某个
提交之后继续新的开发


////////////////////////////
场景2：当前项目有多个分支同时开发，但是都为合并到主分支。分支A要用到分支B中的某几个文件进行功能测试，其他文件不需要变动

这种场景就是我们只需要从当前分支合并另外一个分支中的某几个文件即可，执行步骤(当前是在A分支)：
  git checkout B file1 file2 ...
这样就会把B分支中的几个文件合并到A分支。但是如果A分支中已经包括这几个文件的话，就有可能会产生冲突。此时可以先新建一个A分支
的暂存分支 A_TEMP，先将B分支与 A_TEMP 进行合并，然后再将 A_TEMP 合并到 A 分支。具体操作参考：
  https://www.cnblogs.com/coderxx/p/11544550.html


////////////////////////////
场景3：当一个项目中有多个分支需要合并，但是出现了一些棘手的合并冲突，这个时候要如何处理？
首先要取消此次合并，尝试逐个解决。工作重点应该放到信息收集上，以便了解目标分支当前所发生的一些事情

git log a..b
  表示来自于分支b，但是不属于分支a的提交，这样就可以将两个分支所做的事情独立来看

git merge-base a b
  获取分支a和分支b的共同祖先，可以大致认为是两个分支开始分叉的那次提交。得到这次提交的散列值之后，就可以利用 git diff
  命令比较两个分支相对于此次提交的不同之处，然后再考虑如何进行手动合并


////////////////////////////
场景4：当一个开发者将远程仓库中的某个分支删除之后，我们如何将本地中存在的远程分支给删除掉
  git fetch -p
  其实就相当与同步一下远程仓库中的修改，本地中对应的远程分支也就自然而然的消失了


////////////////////////////
场景5：当某个功能正在进行开发或者修复bug时，突然要添加另外一个功能或者修复bug
  tptfs 中就遇到的一个场景：原本 tptfs 中只有一个块组，后来想要提高整体效率，要增加区分块组的功能。但此时原来的代码中仍然
有一些 bug 没有被解决。个人理解这个时候要新创建一个本地功能分支，专门来开发块组功能，然后当前分支继续对 bug 进行修改。而不是
像现在这样，直接在当前分支添加功能代码，导致每次进行一些 bug 提交的时候还要手动屏蔽掉块组的一些东西，相当麻烦，以后要引以为戒


////////////////////////////
场景6：当另外一个分支添加了超级多新文件或者重命名的时候，merge 到自己分支的时候有发现有太多冲突信息，如何解决？
  此时可以设置一下 git 中的一个属性，限制重命名文件数量：
    git config merge.renameLimit 999999
  后面这个最大数字应该是可以配置的，可以查阅一下
