///////////////// mmap 设备驱动映射 /////////////////
  https://www.cnblogs.com/wanghuaijun/p/7624564.html

参考 x86 CPU 地址空间分配:
  http://tianyu-code.top/Linux%E5%86%85%E6%A0%B8/x86CPU%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D/

linux ioremap:
  https://blog.csdn.net/zqixiao_09/article/details/50859505


///////////////// pcie 总线地址 /////////////////
pci域 / 存储器域 / DRAM域:
  https://blog.csdn.net/chen_xing_hai/article/details/126059029
  https://biscuitos.github.io/blog/PCI-Address-Space/#A


结合上述文章，说说个人关于 PCIE 总线地址与 CPU 可寻址空间的一些思考 (仅供参考):
  - 对于 32-bit CPU 与 64-bit CPU，PCIE 总线地址空间的处理方式应该是不同的。32位处理器最大可寻址空间为 4GB，pcie 总线所能
    管理的地址空间可能也是4G，并且我们不可能把所有的空间都分配给 PCIE 总线。所以，此种情况下应该是只映射其中一部分空间，然后再由
    PCIE 总线去转换到 4G 空间的某个位置
  
  - 但是对于64位CPU，目前来看还不会出现地址空间不足的情况，所以可以映射所有的空间。那既然这样，为什么我们不直接把设备映射到cpu地址
    空间，还要经过 pcie 总线来做？ 首先一个原因，cpu 访问设备是一个复杂的过程，不仅仅是简单访问一些寄存器，还有时序控制等等，可能
    总线能帮我们完成这方面的操作。然后就要考虑可扩展的问题了，我们不可能把所有的设备都直连到 cpu 引脚上，而是应该通过总线构成一个
    树状结构，能够动态增删节点，使用起来也比较灵活；

    就算都进行直连，设备与cpu总要有个通信协议，硬件上来讲，也需要辅之一些时钟或者空间引脚。如果全部直接整合到 CPU，应该也不太好处理。
    采用总线的话，其实就相当于中间做了一步转换，把各种复杂类型的数据都统一成一种格式，cpu 只需对这一种数据进行处理即可，硬件上也可以
    简化
      https://bbs.huaweicloud.com/blogs/374676