///////////////// 为什么要有中断？ /////////////////
  - 中断源(外设)有事件需要 CPU 响应
  - 有事件需要CPU 处理时，中断源根据cpu给定的方式产生中断，cpu跳转到特定地址-中断向量

硬件也会引入中断控制器，相当于在cpu和中断源之间的一个中间件，帮助cpu更好处理中断


///////////////// 软件如何处理中断？ /////////////////
  软件是通过中断号来分辨。就比如外设 a 和 b，a 用于控制一个红灯闪烁，b 用于控制绿灯闪烁
那 cpu 中就要给这两个动作分别申请中断号，假设是 1 和 2。这样当a来信号的时候，cpu 就知道得到中断号 1，那么它就去执行将红灯点亮的操作。b 同理

///////////////// 硬件封装层 /////////////////
- 中断向量一般是利用汇编代码去写
- 当多个中断同时产生？ 需要对各个中断的优先级进行控制
- 中断号如何得到？ 向 CPU 发出请求后，提供某种机制让 CPU 获得实际的中断源
- 控制各个中断的电气触发条件，例如边缘触发或者电平触发
- 如何控制是否响应中断？ 提供使能(enable)或者屏蔽(mask)某一个中断。就比如说红灯已经被点亮了，结果外设a又发来了一个中断请求，这个时候就要忽略掉
- 提供嵌套中断请求的能力。这个就类似于进程切换，当系统在处理低优先级中断时，来了一个高优先级的中断请求，那么就要优先处理高优先级中断
- 提供清楚中断请求的机制(ack)。比如红灯被点亮之后，熄灭了。那么系统就要能够再次处理外设a的中断请求，而不能再忽略
- 有些控制器还需要 cpu 在中断处理完成之后，给控制器回复 eoi (end of interrept)
- 在 smp 系统中，中断处理优先选择哪个cpu？ 需要控制各个中断与cpu之间的亲缘关系(affinity)
- 硬件中断号映射中断号的软件抽象
- 级联的中断控制器。这个感觉类似设备树，子级中断通过不断触发父级中断，最终传递给 cpu？
- 系统中多个中断控制器有着重复的中断号？ 也有机制来处理这个，后续调研


有些中断是不能被抢占的，一旦处理，其他中断只能等该中断完成之后再被执行
不同架构的 cpu 中断处理时不一样的，会有特定的处理方式

///////////////// ARM /////////////////
ARM - linux 软中断是通过 swi 汇编指令产生的

硬中断遵循三段式中断模型:
  中断源: timer button
  中断控制器: INTMOD / INTPEND / INTMASK
  中断核心层: CPSR 寄存器

中断控制器向核心层通信方式有两种：
  - FIQ
  - IRQ

CPU 响应中断所做的操作:
  - 切换CPU工作模式到 IRQ 模式
  - 保存返回地址到 IRQ 模式下的 R14
  - CPSR 保存到 IRQ 模式下的 SPSR
  - PC 跳转到异常向量表入口地址

  异常向量表:
    0x0: ...
    0x4: 未定义指令入口
    0x8: 软中断入口
    0xC: ...
    0x18: IRQ 入口

然后再 0x18 地址存放跳转指令(中间还需要编码，去判断是哪个中断源产生的中断)，然后跳转到中断处理程序当中。一般中断处理程序会做三件事:
  - 保存处理器现场
  - 调用中断处理子程序: 真正的中断处理功能
  - 恢复处理器现场

ARM-9 PC 跳转又多了另外一条了路径，还是跳转到 0x18，但是指向的却是中断向量控制器。然后利用中断源服务地址寄存器中的存储数据跳转到
中断处理程序

不论是硬件设备产生的中断，或者是系统内部产生的中断，如果想让 CPU 响应的话，最底层的实现原理就是将中断信息写入到特定寄存器当中。
这个过程可以是由硬件触发，通过中断控制器写入到寄存器中，也可以是软件通过响应的指令进行写入。两个应该就只是方式的区别，底层实现
原理是一致的；
中断其实就是告诉 CPU 去执行某些个动作，所以只要能够获取到行为信息即可，具体是如何传递过来的，CPU 并不关心，只不过要求把这些信息
写到特定的寄存器即可
  https://www.pianshen.com/article/7896668872/
  http://rcore-os.cn/rCore-Tutorial-deploy/docs/lab-1/guide/part-2.html


///////////////// sifive fu740 interrupt /////////////////
FU740-C000 支持 Machine Mode 中断和 Supervisor Mode 中断，然后还支持 riscv local/global 中断

local 中断通过专用中断值直接发送到单个 hart。这允许减少中断延迟，因为不需要仲裁来确定哪个 hart 将服务于给定的请求，
并且不需要额外的存储器访问来确定中断的原因

CLINT: Core-Local Interruptor
  - 软件和时钟中断是由 clint 产生的 local 中断
  - fu740 没有再包含其他的 local 中断资源

PLIC: Platform-Level Interrupt Controller
  - global 中断通过 plic 进行路由，可以通过 external interrupt 将中断引导到任何一个 hart
  - 平台允许 global 中断与 harts 进行解耦合 (plic)

默认情况下，所有中断都在 machine mode 下处理。对于支持 supervisor mode 的 harts，可以选择性地将中断委托给 supervisor