////////////// 20211122 //////////////
  GR 中的每个 entry 都是8字节的数据，可以是字符串、指针等。感觉还是直接放指针会比较好，要不然还需要再写出另外
一个程序来解析其中的内容。跟之前的认识是不一样的，原来一直以为是把一个类对象直接注册进去

  文件树我们可以只针对 tptfs 来做，如果热插拔了一个存储设备，上面的文件我们还是按照目前已有的方式来处理就好。因为
热插拔设备或者磁盘文件系统的挂载有可能里面会有非常多的文件。如果全部添加到文件树当中，那文件访问的效率还真不一定比
现在的模式要高效，因为我们最终还是要通过读取磁盘来获取文件数据，而不是像tptfs这样直接操作内存地址

  操作系统中数据查找最好是一次就能找到，所以对于现有的数据结构或者函数可以进行适当修改(比如在数据结构中增加一些指针成员)


////////////// 20211123 //////////////
  由于文件树是一种非常不规则的树，所以现有的一些特殊的数据结构，比如 BTree/B+Tree 等都不太适用 (如果整个文件系统都使用
BTree 来管理貌似是可以的，参考 btrfs)。目前比较可行的方案就是参考一些内存文件系统管理文件的方式，比如 tmpfs。它们本身
就是纯内存文件系统，所以它们管理文件跟磁盘文件系统是完全不一样的，通常都是建立树或者链表来实现。
  奇海需要在 global registry 中构建一个文件树来实现文件查找，其实完全可以借鉴这些内存文件系统的文件组织管理方式。存储
空间的申请和读写等操作可以忽略掉，保留创建和查找机制


////////////// 20211124 //////////////
  奇海文件树的建立不仅仅需要修改 vfs 层级的代码，也需要修改底层文件系统的代码。就比如说当我们需要创建一个新文件的时候，其实
是要经过一系列的查找和 vnode 分配等动作，最后调用文件系统的 vop_create 函数，文件注册还是要在文件系统层级来实现

  参考 tmpfs_node 的设计和处理过程，当前可以先做出来一个简单版本，暂时不去考虑性能问题。

  tptfs 需要修改的地方包括文件的创建、删除、重命名、移动、链接，还要注意 vnode、inode 与节点建立映射的时机。tptfs 中一旦
inode 与树节点建立的映射，除非文件删除，否则应该不会断开连接


////////////// 20211125 //////////////
  文件树创建过程：
    1、在 tptfs mount 的时候实例化出树对象和整个树的root节点

  
  文件树由于其结构的特殊性，所以目前还找不到一个成熟的、高性能的数据结构来构建它。所以，个人理解应该要把文件树的功能聚焦于某一点，
而不应该面面俱到。比如说文件树最主要的功能就是建立 vnode、file 和 inode 三者之间的关系，并且要最大限度的实现快速查找，那么我们
所设计的结构就要以查找快速性作为主要指标。
  数据处理我们就交给文件系统来做，比如用户执行了一个 ls 命令，文件树所要做的工作是快速匹配到该目录对应的 inode，然后执行 readdir。
而不是去遍历该文件节点所有的子节点，然后将信息返回给应用程序

  搜索树的查找效率是比较高的，不管是二叉树还是多叉树，而且具有平衡特性的树平均查找时间应该是最少的。但是这种数据结构在动态构建的过程中
会为了保持平衡而发生旋转，这就会破坏文件树从属关系。比如说本来 B文件 是在 A目录下，但是旋转之后可能 B就到了旋转到了C目录下。这样我们
查找的时候就乱了。
  但是，如果我们把每一个目录项中的所有文件独立出来，单独做成一个目录树，不管什么操作只针对该树来进行，上层结点保留一个指针始终指向这棵
树的根节点就可以。这样不管这棵树怎么旋转，即使根节点变了，它所表示的也仅仅是该目录中的文件，别的节点不受任何影响


////////////// 20211126 //////////////
  tmpfs 利用 tmpfs_mount->tm_nodes_used 来注册所有的 tmpfs_node，之用一个链表管理所有的文件节点挺奇怪的

  btrfs 是完全利用 BTree 来管理所有的文件和数据，需要注意它所有的树节点在内存中创建完成之后会不会同步到磁盘。(应该是要同步到磁盘，
否则关机之后整个树就没了)


////////////// 周会总结 //////////////
  文件树的构建也不一定要采用平衡树之类的数据结构，正常情况下就算是一个文件中包含有很多文件，利用链表也是可以很快查找到的。或者是在节点中添加一个文件计数，
当目录中的子文件超过多少数量的时候，我们就启用树状结构来管理所有文件；如果文件数量比较少，那就直接使用链表结构来管理

  更重要的方面是要考虑当有多个进程同时访问一个文件的时候，文件树要怎么来处理。比如当一个进程正在读取一个文件的时候，另外一个进程要对这个文件进行写操作，
或者更严重一些，他要删除这个文件，这个时候该文件节点要怎么来处理

  当多个进程同时处理一个文件时，比较合理的机制是多读一写，并且写之前要先判断是否有进程正在读取该文件。如果有的话，就等待所有进程读取完毕之后再写。其实
就是要把当前文件同步机制跟文件树关联起来。要去看一下 semaphore 和 mutex 的使用

  Global Registry 不能仅仅注册一个 root 节点，而是要把所有的文件都注册进去，这其实会涉及到当我们把一个节点锁住并访问其中一个子文件A的时候，如何去访问
另外一个子文件B。因为只要我们知道 B文件在 GR 中的地址，就可以不通过目录文件节点来访问 B文件