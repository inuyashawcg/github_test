////////////// 20210830 //////////////

  TptReadDir 调试过程中发现，一些在磁盘文件系统中需要加锁的地方，在内存文件系统中添加可能会导致错误发生。
比如 vop_stat 和 vop_close 函数中，ufs 和 ext2 会对 vnode 进行加锁操作用来更新时间字段；在 tmpfs 中
则是直接更改相关字段，无需加锁。

  所以，要关注一下 vnode 等结构体中的锁的具体作用是什么。如上述所说，可能 vnode 的锁操作是需要在磁盘读写操作
的时候才会被用到，而如果数据已经在内存中的话，就没必要再加锁。tmpfs 所有的数据都是在内存中，所以不用加锁。也有
可能是函数实现中对锁的使用方式存在问题，还是要调查一下真正的原因是什么

  挂载 tptfs 之后，执行 ls -al 命令，打印信息会出现两种：

    total 5
    ls: ./.: No error: 0
    drwxr-xr-x   2 root  wheel  512 Aug 30 03:03 .
    drwxr-xr-x  21 root  wheel  512 Aug 30 03:04 ..

    total 5
    drwxr-xr-x   2 root  wheel  512 Aug 30 03:03 .
    drwxr-xr-x  21 root  wheel  512 Aug 30 03:04 ..


  htree 中的 root node 和 node 的设计要参考目录项结构体的设计，因为其中包括了一个 fake_dirent 结构体，它就是
用来模拟目录项结构的。这就要求我们需要把两者的字段一一对应起来，否者赋值或解析的时候会出现错误，这一点要特别注意
  .. 目录的大小是除去第一个目录项之后的剩余空间的大小，初始化的时候也要注意

  
TptfsMount::MkfsMakedir 返回值
  线性查找的时候，我们所要读取的数据只有 . 和 .. 两个目录项的内容，所以返回值(也就是 tpti_size)就只有两个目录项的大小，也就是 256 bytes；
当我们切换到 hash tree 查找的时候，inode 的大小就不仅仅是两个目录项，还会包含 root_info，htree_entry 等等，这些数据的大小刚好是一个数据块
的大小。所以返回值应该是一整个数据块的大小，也就是 4096 bytes

TptfsVnode::TptReclaim
  在 ext2 中，该函数会有一个 free inode 的一个操作，这是因为磁盘文件系统中磁盘跟内存中的 inode 其实是不一样的，我们需要通过 malloc 函数
为内存中的 inode 分配存储空间，然后通过文件系统内部函数与磁盘上的 inode 建立映射关系。

  tptfs 中所有的 inode 其实都是在内存当中，我们访问一个 inode 直接指向其所在的虚拟地址即可，所以是不需要 malloc 的，也就不存在 free 操作


////////////// 20210831 //////////////
  ext2_htree_has_idx (TptHtreeHasIdx) 函数需要判断文件系统是否要具备 hash index 的属性。也就是说如果我们想要利用目录项的 hash 查找，
就必须要设置该属性到超级块当中，所以在 tptfs 初始化过程中需要增加一步操作