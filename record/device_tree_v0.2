device tree主要是用来描述一些不能动态检测的设备的信息，能够表示整个系统的设备结点

命名方式为 node-name@unit-address，长度不能超过31个字符，支持字符的大小写，名字要反映出设备的类型

名称的单元地址部分依赖于节点所在的总线类型，一般设备会有一个reg属性元素，里边会保存设备相关的地址，这个时候，名字中的地址要匹配reg中的第一个地址。如果设备没有reg属性，那在同一级中的设备命名的时候要注意区分，一个特定总线的绑定可以为reg格式和单元地址指定额外的、更具体的要求

节点的名称应该是通用的，反映设备的功能，而不是其精确的编程模型

通过指定从根节点到所有子节点到所需节点的完整路径，可以唯一地标识设备树中的节点，根节点的路径是/

////////////////////////////
Standard Properties(标准特性)

compatible: string list(这个应该表示的是设备的名称，其实也是驱动的名称)
	该属性会包含一个或者多个字符串，这些字符用于设备驱动的查找
	格式一般是"manufacturer,model"，manufacturer表示制造商，model表示模块编号，可以理解为是设备标识
	compatible = "fsl,mpc8641", "ns16550"; 上述例子中系统首先会去定位一个支持mpc8641的驱动，如果没有找到的话，再去找
	支持ns16550设备的驱动

model: string
	用来表示设备的制造商模块编号
	model = "fsl,MPC8349EMITX";

phandle: u32
	为设备树中的设备结点指定一个唯一的数字标识符。其他结点如果需要引用该结点的相关属性时，可以通过phandle来绑定
	pic@10000000 {
		phandle = <1>;
		interrupt-controller;
	};

	another-device-node {
		interrupt-parent = <1>;
	};

status: string
	 表示设备的状态
	 "okey": 表示设备正在运行
	 "disabled": 表示设备目前没有运行，但是将来可能会变成运行状态，这个要参考具体设备对于该状态的定义
	 "fail": 表示设备没有运行，设备检测到了严重的错误，如果不经过维修的话无法正常工作
	 "fail-sss": 同上，sss表示检测到的错误信息

#address-cells and #size-cells: u32
	不同的平台，不同的总线，地址位长度可能不同，有32位地址，有64位地址，为了适应这个，规范规定一个32位的长度为一个cell。"#address-cells"属性用来表示总线地址需要几个cell表示，该属性本身是u32类型的。"#size-cells"属性用来表示子总线地址空间的长度需要几个cell表示，属性本身的类型也是u32。可以这么理解父节点表示总线，总线上每个设备的地址长度以及地址范围是总线的一个特性，用"#address-cells","#size-cells"属性表示，比如总线是32位，那么"#address-cells"设置成1就可以了。这两个属性不可以继承，就是说在未定义这两个属性的时候，不会继承更高一级父节点的设置，如果没有设置的话，内核默认认为"#address-cells"为2，"#size-cells"为1

	soc {
		#address-cells = <1>;
		#size-cells = <1>;

		serial {
			compatible = "ns16550";
			reg = <0x4600 0x100>;
			clock-frequency = <0>;
			interrupts = <0xA 0x8>;
			interrupt-parent = <&ipic>;
		};
	};

reg: <prop encoded array>编码为任意数量的(address, size) pairs
	描述了设备在父总线定义的地址空间范围内的资源地址，最常见的是指内存映射IO寄存器块的偏移量和长度，root node在地址空间范围内
	的地址是CPU的真实地址
	指定地址和长度所需的<u32>单元数是总线特有的，由设备节点父节点中的“地址单元”和“大小单元”属性指定
	如果父节点为#size单元格指定值0，则reg值中的长度字段应省略

	假设片上系统中的一个设备有两个寄存器块，SOC中偏移量为0x3000的32字节块和偏移量为0xFE00的256字节块。reg属性的编码如下:（假设#address cells和#size cells值为1）
	reg = <0x3000 0x20 0xFE00 0x100>

virtual-reg: u32
	指定一个有效的地址映射到由reg属性指定的物理地址。该属性能够让boot program向client program提供已经设定好的地址映射

ranges: <empty>或<prop encoded array>编码为任意数量的（child-bus-address, parent-bus-address, length）三元组
	该属性提供了一种定义总线地址空间（子地址空间）和总线节点父节点地址空间（父地址空间）之间的映射或转换的方法
	ranges属性值的格式是任意数量的三元组（子总线地址、父总线地址、长度）
	child-bus-address是子总线地址空间中的物理地址。表示地址的单元数取决于总线，可以从该节点（出现ranges属性的节点）的地址单元确定
	parent-bus-address是父总线地址空间中的物理地址。表示父地址的单元数取决于总线，可以从定义父地址空间的节点的#address cells属性确定
	length指定子地址空间中范围的大小。表示大小的单元格数可以从该节点（ranges属性出现的节点）的#size-cells单元格中确定
	如果属性是用<empty>值定义的，它指定父地址空间和子地址空间相同，并且不需要地址转换
	如果总线节点中不存在该属性，则假定该节点的子节点与父地址空间之间不存在映射

	soc {
		compatible = "simple-bus";
		#address-cells = <1>;
		#size-cells = <1>;
		ranges = <0x0 0xe0000000 0x00100000>;

		serial {
			device_type = "serial";
			compatible = "ns16550";
			reg = <0x4600 0x100>;
			clock-frequency = <0>;
			interrupts = <0xA 0x8>;
			interrupt-parent = <&ipic>;
		};
	};
	ranges指定了1024KB的地址空间大小，寻址到物理地址0x0的子节点映射到0xe0000000.通过这个映射，串口设备可以在地址0xe0004600处进行加载或存储，偏移量为0x4600（在reg中指定）加上在ranges中指定的0xe000000映射

dma-ranges: <empty>或<prop encoded array>编码为任意数量的（child-bus-address, parent-bus-address,length）三元组
	该属性通常被用于描述内存映射总线(其devicetree父级可以访问源于总线的DMA操作)的DMA结构
	它提供了一种在总线的物理地址空间和总线的父级的物理地址空间之间定义映射或转换的方法
	dmaranges属性值的格式是任意数量的三元组（子总线地址、父总线地址、长度）。指定的每个三元组描述一个连续的DMA地址范围
	child-bus-address是在子总线空间范围内的物理地址，用于表示地址的cell数量取决于总线和结点(dma-ranges属性出现的结点)的#address-cells
	parent-bus-address是在父总线空间范围内的物理地址，用于表示地址的cell数量依赖于总线，也可以从定义父地址空间的节点的#address cells属性确定
	length指定子地址空间中范围的大小。表示大小的单元数可以根据这个节点（dmaranges属性出现的节点）的#size-cells来确定


////////////////////////////
中断及其映射
	
表示中断生成设备的结点一般都会包含一个interrupt-parent(终端控制器相关)属性。如果一个中断生成设备没有包含该属性，它的中断父级默认是设备树的父级

每一个中断产生设备都会包含一个interrupts属性来描述设备所需要的中断资源，每个资源都会用一个名叫interrupt specifier的量来表示。中断说明符的格式和意义是特定于中断域的，也就是说，它依赖于中断域根节点上的属性。
中断域的根结点使用#interrupt-cells来定义对中断说明符进行编码所需的<u32>值的数值
中断域是解释中断说明符的上下文。域的根结点是（1）中断控制器或（2）中断nexus
1. 中断控制器是物理设备，需要一个驱动程序来处理通过它的中断。它也可以级联到另一个中断域。中断控制器由devicetree中该节点上的中断控制器属性指定
2. 中断nexus定义了一个中断域和另一个中断域之间的转换。转换基于特定于域和总线的信息。域之间的这种转换是用interrupt-map属性执行的。