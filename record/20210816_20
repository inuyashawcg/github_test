////////////// 20210816 //////////////
  当文件系统规模不断扩大的时候，每个数据段占用的空间是越来越大的，这就增加了分配一个数据块需要查找的时间。
所以，后面可能还需要考虑对查找机制进行改进，可以参考 htree 的设计思路，在当前目录项查找机制上层添加 hash 树
来进行管理，减少了查找花费的时间

  块组可以认为是对磁盘进行了拆分，每一个块组都是结构相同的独立部分。tptfs 目前的设计可以大致认为是只保留一个块组。
从另一个角度思考，就是将原有的分散的数据区进行了统一，类似于目标文件的链接过程，将不同目标文件中的相同的 section
合并成输出文件中的一个 section。这样就方便管理。我们可以在对整个区域进行分段，每一段对应树结构的一个叶结点，查找
的时候先搜索叶结点，然后再对应到数据区的某个部分，算是一种解决思路

  ext2_blkpref 函数中采用了一种类似局部性原理的设计，就是在分配磁盘块的时候，会尽量将同一个文件的数据块集中到一起。
当然这是为提高磁盘性能采取的一种优化措施。但其实在 tptfs 中同样适用。
  目前持久化内存设计中，虚拟页与磁盘物理块是随机映射的，这其实就会导致一个问题，就是相邻两个虚拟页可能会映射到距离
非常远的磁盘块上。这种情况会增加磁头运动距离，降低数据访问效率。所以，虚拟页跟磁盘块的映射后续可能也需要优化匹配
机制，尽量将相邻的虚拟页放到相邻的磁盘块。
  同样，在 tptfs 中也要做相应的处理，那就是将相同文件的数据页尽量放到一起。经过这两次的处理，能够让文件在磁盘的位置
更加紧凑一些，提高磁盘效率

////////////// 20210817 //////////////
  bread() 函数的用法从一些实际用例来看非常奇怪，这里简单列举一下: (已经添加到了 TODO 文件中)
    情景一: 持久化内存对于磁盘的读取直接将 逻辑块号 * 8 传入，可以正确读取存放在磁盘上的数据。这里就可以认为逻辑块号
      就是磁盘块号
    情景二: 在 ext2文件系统 ext_balloc() 函数中也调用了 bread 函数，但是这里比较奇怪的一点就是传入的参数是文件的逻辑
      块号。所以它不可能表示的是磁盘对应的块号，因为文件的逻辑块号都会有重复的情况，不能所有的文件调用 bread 函数的时候
      都去读取同一个磁盘块

  情形一应该是 bread 函数最常规的用法，情形二中的用法应该是关联了 bmap 函数。所以 tptfs 的实现中，对于需要调用 bread
函数的情况，个人理解是要增加 bmap 操作，而 getblk 函数可能仅仅是返回一个 struct buf，它会包含逻辑块号和磁盘物理块号两个
字段，可能会用于缓存机制。猜测是通过查找 vnode 对应的 buf 的逻辑块号，检查需要读取的块数据是不是在缓存中？

////////////// 20210818 //////////////
  奇海操作系统未来考虑使用的都是固态硬盘，不会出现像机械硬盘这样移动磁头读取数据的情况。所以即使持久化内存中相邻虚拟页
映射到了距离相对较远的位置，对于数据的访问速度是没有什么影响的。但是每个文件对应的虚拟页也还是尽量靠近吧(局部性原理)

ext 中出现了一个 ext2_reallocblks 函数，作用是将块序列重新分配为连续的块序列。在奇海中这个应该是可以删减掉了

ext_balloc 和 ext_bmap 两个函数对于 bread/getblk 的使用不太一样。bmap 应该是在所有的映射都已经建立完成之后进行，对应磁盘
块中已经完成了数据填充。balloc 因为要涉及到新磁盘块的获取，所以要区分磁盘块中有数据和没有数据的情况

////////////// 20210819 //////////////
  在 ext2_zero_inode_table 函数中有计算块组中未被使用的 inode 的操作，利用是块组描述符中的相应字段。tptfs 目前还是按照 ext2
的机制来进行的开发，所以需要在超级块中添加一个对应的字段来储存文件系统未被使用的 inode 的数量

  ext2 块组描述符中包含有 inode free count 和 inode unused count 两个字段，这两个字段有差吗？？

////////////// 20210820 //////////////
  编译器对于一些已经存在的文件的处理可以借助 global registry。文件在 global registery 的形式应该是类似于树型查找，我们注册的话
应该是把现有的整个文件系统的路径进行注册，每个结点对应一个entry，查找的时候还是可以按照当前逻辑进行。然后我们执行 fopen 函数的时候
就可以把其中给定的路径解析并替换成对应的虚拟地址。

  正如上面所说，编译器的行为偏向于确定性，操作系统对于文件的处理带有很大的不确定性，两者之间就需要搭建一个桥梁，编译器将文件访问入口
变成某个确定的地址，具体对数据的操作就交给操作系统来完成。目前来看比较合适的就是每个文件的 inode。

  所以，在 global registry 中注册的信息可以是每个文件的 inode 和虚拟地址。这样只要搜索到这个inode，我们就可以确定它的虚拟地址，
如果应用程序里面有操作该函数的处理逻辑，就可以直接指向 inode 的入口地址，就不需要再进行一步一步的查找了。但是现有的方式还是要保留，
用户手动创建文件这些操作还是要支持，还有 ls / cd 这些常用指令应该还是要现有的方式才能支持的

  ext2_alloc.c - ext2_alloccg() 函数参数中包含有一个 bpref，从代码逻辑来看表示的应该是绝对块号，而我们要计算的其实是相对块号，
要注意这里的处理方法


////////////// 20210822 //////////////
翻译程序:
  把一种语言程序(源语言程序)等价转换成另外一种语言程序的(目标语言程序)的程序
  源语言程序 -> 翻译程序翻译 -> 目标语言程序

编译程序:
  编译程序本质上也是一种翻译程序，它是将一种高级语言程序等价地转换成低级语言程序(汇编或者机器语言)的程序

  诊断编译程序:
    主要是用于帮助程序员发现程序中的错误，用于调试，对目标代码的运行效率不太关注
  优化编译程序:
    主要是用于优化目标代码的运行效率
  交叉编译程序:
    宿主机编译目标机程序

  目前的编译程序基本上会同时提供这功能

解释程序:
  把源程序作为输入，但是不产生目标程序，而仅仅是边解释边执行源程序

源语言 -(前端)-> 中间语言 -(后端)-> 目标语言