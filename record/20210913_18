////////////// 20210913 //////////////
  文件系统判断一个文件类型其实是通过解析 vnode->v_type 实现的，而 v_type 又是通过 inode->i_mode 计算得到的
所以，当我们创建一个新文件的时候，需要将文件的类型信息保存到 i_mode 字段。ext2 文件系统是通过 ext2_vget 函数将
inode 与 vnode 关联到一起的，其中会调用 ext2_vinit 获取文件的类型信息。
  tptfs 在调试的过程中发现即使是通过 touch 命令创建的普通类型文件，umount 之后再重新挂载，它的类型就变成了目录
文件。其实就是在 TptVget 函数中的实现逻辑出现了问题(将 v_type 设置成了定值 VDIR，这就导致无论我们创建了一个怎样
的文件，申请 vnode 的时候类型总是目录类型)

  dd if=/dev/zero of=test.img bs=4096 count=25600


////////////// 20210914 //////////////
  关于文件系统 inode 起始 number 的思考。inode 的话其实是每个文件系统单独管理的对象，而不是 vfs 它所管理的对象。
所以，每个文件系统的 inode 编号都是会有重叠的

  当我们向一个目录项挂载文件系统的时候，文件系统对应的根节点的 vnode 应该就是挂载点对应的 vnode，只是 inode 的话
变成了新文件系统对应的 inode，而不是它之前对应的 inode。当我们 umount 操作之后，之前的那个 inode 就会回到原有的
位置，也就可以看到原有的文件数据又回来了

  ext2_mountfs 的主要功能其实是读取磁盘中的数据，然后创建一个新的 ext2_mount 结构，把磁盘上的 inode 数据读取出来，
实例化 in-memory inode

  struct mount 中包含有两个 vnode 指针，一个表示的是 rootvnode，另外一个表示的是 mnt_vnodecovered，感觉应该是
挂载点的目录项对应的 vnode。执行 mount、umount 操作的时候可能会对这两个参数进行替换，可以实际测试一下

  ls total 表示的应该是这个文件大小是多少 kb；df 读取的可能是超级块中的数据。df 获取的是整个文件系统的信息，比如剩余
多少可用的空间大小，这些数据都是在超级块中存放的。所以调试的话就可以先从 inode i_size 和 stat 函数中的数据开始，并且
需要关注 block alloc 相关函数的逻辑是否正确，因为它会更新超级块中的成员大小

  TptAlloc 函数是为文件分配数据块的功能函数，每次分配完成之后就会修改超级块中的数据，然后执行 df 指令的时候就读取超级块
中的数据成员，然后将信息打印。该函数编写中出现了一个逻辑错误，每次分配一个数据块会将成员自减两次，导致出现负数，修正之后功能
恢复正常


////////////// 20210915 //////////////
  ls total 出错的原因可能是多注册了一个函数 TptStat，这个函数在原有的 ext 或者 ufs 中都是没有的，tmpfs 通过这个函数
获取结点的相关属性信息

  通过 ee / vi 命令向文件内写入数据不会被保存，再次写入数据时 TptIndTruncate 函数会导致 panic。将一些 malloc 数据释放
掉之后，执行上面的指令又会出现打开文件后无法正常退出的情况，考虑是不是卡在了某个函数的循环当中。
  第一次向文件写入数据之后，执行 cat 命令是可以正常读取数据的。但是如果再次写入数据之后，发现原有的数据会被覆盖，然后文件就
无法再次写入。目前猜测是 inode 的相关操作出现了问题

  echo world >> a
    在 ext2 中的 ext2_write 函数中会有一个判断语句：

      	case VREG:
          if (ioflag & IO_APPEND)
            uio->uio_offset = ip->i_size;
          if ((ip->i_flags & APPEND) && uio->uio_offset != ip->i_size)
            return (EPERM);

    >> 其实就会在 io_flag 中添加 IO_APPEND 属性，然后就可以更新 uio->uio_offset，也就是我们需要写入的数据在文件中的偏移量


////////////// 20210917 //////////////

  root@qemu:/tpt # ls -al
    total 18014398509481664
    drwxr-xr-x   3 root  wheel   4096 Sep 17 01:53 .
    drwxr-xr-x  23 root  wheel    512 Sep 17 01:46 ..
    drwxr-xr-x   2 root  wheel   4096 Sep 17 01:47 b
    -r--r--r--   1 root  wheel  81920 Sep 17 01:53 menu.4th

  出现上述现象的操作步骤：
    首先利用 dd 命令创建一个新的创建一个新的测试文件，大小是 80k = 81920 bytes，利用 cp 命令将该文件拷贝到 /tpt，文件大小是正确的。
  但是当我们把这个文件删除，拷贝另外一个文件到该路径下之后，发现显示的还是上次文件的属性信息，而不是更新后文件的信息。也就是说 inode 的
  信息没有事实更新，猜测应该是 TptVFree 函数存在问题。我们应该再把 inode 移除之后顺便将数据同步清除掉？


  这个问题的起因是 tptfs inode 回收机制出现了问题，即 TptClaim 函数。这个函数一般是在我们删除一个文件的时候调用，这样原有文件所占用的
那个 inode 就会被系统回收。回收调用的是 vfs_hash_remove 函数。
  tptfs 中该函数的实现跟 ext2 稍微有些差异，ext2 中 vnode 对应的 inode 是通过 malloc 函数实例化的，而 tptfs 直接指向 inode 所在的
虚拟地址，所以不需要执行 free 操作，但是要把原有的数据清除掉，利用的是 bzero 函数


////////////// 20210918 //////////////
  九一八事变，勿忘历史

  当目录项数量超过一个数据块所能承受的最大数量时，开始建立 htree 来管理目录项：

    TptDirEnter----------------------------------
    TptHtreeHasIdx----------------------------------
    TptHtreeHasIdx----------------------------------
    TptHtreeCreateIndex----------------------------------
    TptBmap---------------------
    TptBmapArray---------------------
    TptHtreeCreateIndex: while-----1111111
    TptHtreeCreateIndex: while-----1111111
    TptHtreeCreateIndex: while-----1111111
    TptHtreeCreateIndex: while-----1111111
    TptHtreeCreateIndex: while-----1111111
    TptHtreeCreateIndex: while-----1111111
    TptHtreeCreateIndex: while-----1111111
    TptHtreeCreateIndex: while-----1111111
    TptHtreeCreateIndex: while-----1111111
    TptHtreeCreateIndex: while-----1111111
    TptHtreeCreateIndex: while-----1111111
    TptHtreeCreateIndex: while-----1111111
    TptHtreeCreateIndex: while-----1111111
    TptHtreeCreateIndex: while-----1111111
    TptHtreeSetBlock----------------------------------
    TptHtreeSetCount----------------------------------
    TptHtreeRootLimit----------------------------------
    TptHtreeSetLimit----------------------------------
    TptGetHashSeed----------------------------------
    TptHtreeSplitDirblock----------------------------------
    TptHtreeCmpSortEntry----------------------------------
    TptHtreeCmpSortEntry----------------------------------
    TptHtreeCmpSortEntry----------------------------------
    TptHtreeCmpSortEntry----------------------------------
    TptHtreeCmpSortEntry----------------------------------
    TptHtreeCmpSortEntry----------------------------------
    TptHtreeCmpSortEntry----------------------------------
    TptHtreeCmpSortEntry----------------------------------
    TptHtreeCmpSortEntry----------------------------------
    TptHtreeCmpSortEntry----------------------------------
    TptHtreeCmpSortEntry----------------------------------
    TptHtreeCmpSortEntry----------------------------------
    TptHtreeCmpSortEntry----------------------------------
    TptHtreeCmpSortEntry----------------------------------
    TptHtreeCmpSortEntry----------------------------------
    TptHtreeCmpSortEntry----------------------------------
    TptAppendEntry----------------------------------
    TptHtreeInsertEntry----------------------------------
    TptHtreeInsertEntryToLevel----------------------------------
    TptHtreeGetCount----------------------------------
    TptHtreeSetBlock----------------------------------
    TptHtreeSetHash----------------------------------
    TptHtreeSetCount----------------------------------
    TptHtreeAppendBlock----------------------------------
    TptWrite----------------------------------
    TptBallocx----------------------------------
    TptAllocx----------------------------------
    TptHashAlloc----------------------------------
    TptAllocg----------------------------------
    TptGetNbFree----------------------------------
    TptGetNbFree----------------------------------
    TptGetNbFree----------------------------------
    TptSetNbFree----------------------------------
    TptUpdate----------------------------------
    TptItimes----------------------------------
    TptHtreeAppendBlock----------------------------------

    TptHtreeCreateIndex: while-----1111111 语句一共打印了14次，因为整个数据块最多可以容纳16个目录项，除去 . 和 .. 两个
  对象，还剩下14个，while 循环全部覆盖到了。这个操作就是为了定位数据块最后一个成员所在的位置


    KDB: stack backtrace:
    #0 0xffffffc0004b2d70 at kdb_backtrace+0x86
    #1 0xffffffc00043e750 at vpanic+0x20c
    #2 0xffffffc00043e540 at panic+0x32
    #3 0xffffffc00089a740 at do_trap_supervisor+0x670
    #4 0xffffffc00089a1f6 at do_trap_supervisor+0x126
    #5 0xffffffc000882748 at cpu_exception_handler_supervisor+0x68
    #6 0xffffffc000571552 at vop_eagain+0x1be
    #7 0xffffffc00056f2c4 at vop_stdaccessx+0x190
    #8 0xffffffc0005a2978 at sys_funlinkat+0xc2
    #9 0xffffffc0005a31e2 at kern_statat+0x156
    #10 0xffffffc0005a304a at sys_fstatat+0x3c
    #11 0xffffffc00089b174 at do_trap_user+0xa28
    #12 0xffffffc00089aa46 at do_trap_user+0x2fa
    #13 0xffffffc00089a888 at do_trap_user+0x13c
    #14 0xffffffc000882812 at cpu_exception_handler_user+0x72
    Uptime: 22m56s

