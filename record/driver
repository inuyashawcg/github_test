////////////////
驱动加载方式:
	1. 静态方式编译到系统内核
	2. 借助可加载模块（loadable kernel module， KLD）机制以动态的方式加载

一般来说，KLD都会包含有如下两个部分：
	1. 模块事件处理程序，主要是用来处理KLD初始化和退出等事件的函数
	2. 调用DECLARE_MODULE宏一次（有必要将这个宏彻底搞清楚）

所以，如果要跟marss中的device（应该是属于字符设备）交互，目前第一步要做的就是要确认到底采用那种方式加载驱动程序


///////////////
字符驱动设备程序通过生成字符设备文件来访问硬件设备，在FreeBSD 4.0以后的版本中，多数驱动程序都会有一个字符设备接口

一般而言，字符设备通常包含有三个接口：
	1. 一套d_foo函数，其实就是对设备的一些输入输出操作函数，比如read，write，open，close等等
	2. 字符设备开关表，它会指明在驱动设备程序中那些d_foo函数是已经被实现了的，不需要定义所有的d_foo函数或者属性，
		其中会包含有两个成员: d_version(驱动所支持的FreeBSD版本号),和d_name（给出驱动的名称），这两个是必须要定义的
	3. make_dev函数的调用和destroy_dev函数的调用


///////////////
设备的通信与控制

驱动程序除了要与设备进行数据交换之外，还有执行其他的一些操作，比如说报告出错信息，弹出可移动自媒体或者自销毁时序等等，所以还牵涉到许多其他方面的控制

ioctl: 输入输出控制接口（input/output control interface），通常用于设备的通信与控制
sysctl: 系统控制接口（system control interface），用于动态改变或者检查内核参数，这里的内核包括设备驱动程序


///////////////
Newbus和资源分配
自动配置是FreeBSD在机器中启用设备时所执行的过程，它会系统的检测机器的输入输出总线(I/O bus)识别出其中的子设备，对于每个能识别的设备，自动配置将指派
合适的Newbus驱动程序来配置和初始化它。这里可能会出现设备无法识别的情况，这时候Newbus是不会自动分配驱动程序给它

一般情况下，Newbus驱动程序会包含如下三个部分:
	1. 一套device_foo函数，大体而言这些函数都是在Newbus驱动程序自动配置期间能够执行的操作
	2. 一个设备房发表
	3. DRIVER_MODULE宏的调用

自动配置会首先是别每个输入输出总线上的子设备，现在设计的总线都是可以直接识别连接在上面的设备，一些老的总线(ISA)则必须使用它所关联的驱动程序提供的
device_identify例程来识别其子设备

所有识别的子设备都会传递给各个Newbus驱动程序的device_probe函数，而device_probe函数也会告诉内核响应的驱动程序是否可以操纵该设备
有时候会出现多个驱动设备程序操控一个设备的情况，这时候就需要通过device_probe函数的返回值来区分设备和驱动的匹配程度，选取其中的最佳匹配。而一旦找到了
最佳匹配驱动，就会调用device_attach函数用于初始化设备和基础软件(例如设备节点文件)

作为配置和操控设备的一部分，驱动程序也需要管理硬件资源，主要包括:
	1. 中断请求线(Interrupt-request Line, IRQ)
	2. 输入输出端口(I/O port)
	3. 输入输出内存(I/O memory)

///////////////
中断处理

硬件设备通常需要执行或处理外部事件，比如旋转磁盘，等待输入输出等。这类外部事件的执行比处理器慢得多，所以为了防止处理器因为等待而闲置，操作系统提供了一套
终端机制。简单来说，中断是指硬件设备在需要引起处理器注意的时候发送的信号。总之，驱动程序只需要注册一个处理程序函数以服务相应设备的中断请求即可

在FreeBSD中，中断处理程序通常由一个过滤器例程或者ithread例程组成(或者两者兼有)。过滤器例程在主中断上下文中运行(也就是说，它没有自己的上下文)，因此它不能
阻塞或者执行上下文切换，只能通过自旋锁机制来实现同步。由于这些限制，过滤器例程一般只能用于要求非抢占式中断处理程序的设备

和过滤器例程不同，ithread例程在它自己的县城上下文中运行。ithread例程可以执行除了主动上下文切换(即休眠)或等待条件变量以外的任何操作。由于过滤器例程是
非抢占式的，FreeBSD中的多数中断处理程序都是ithread例程