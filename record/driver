////////////////
驱动加载方式:
	1. 静态方式编译到系统内核
	2. 借助可加载模块（loadable kernel module， KLD）机制以动态的方式加载

一般来说，KLD都会包含有如下两个部分：
	1. 模块事件处理程序，主要是用来处理KLD初始化和退出等事件的函数
	2. 调用DECLARE_MODULE宏一次（有必要将这个宏彻底搞清楚）

所以，如果要跟marss中的device（应该是属于字符设备）交互，目前第一步要做的就是要确认到底采用那种方式加载驱动程序


///////////////
字符驱动设备程序通过生成字符设备文件来访问硬件设备，在FreeBSD 4.0以后的版本中，多数驱动程序都会有一个字符设备接口

一般而言，字符设备通常包含有三个接口：
	1. 一套d_foo函数，其实就是对设备的一些输入输出操作函数，比如read，write，open，close等等
	2. 字符设备开关表，它会指明在驱动设备程序中那些d_foo函数是已经被实现了的，不需要定义所有的d_foo函数或者属性，
		其中会包含有两个成员: d_version(驱动所支持的FreeBSD版本号),和d_name（给出驱动的名称），这两个是必须要定义的
	3. make_dev函数的调用和destroy_dev函数的调用


///////////////
设备的通信与控制

驱动程序除了要与设备进行数据交换之外，还有执行其他的一些操作，比如说报告出错信息，弹出可移动自媒体或者自销毁时序等等，所以还牵涉到许多其他方面的控制

ioctl: 输入输出控制接口（input/output control interface），通常用于设备的通信与控制
sysctl: 系统控制接口（system control interface），用于动态改变或者检查内核参数，这里的内核包括设备驱动程序