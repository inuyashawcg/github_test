////////////// make 基础 //////////////
在实际工作中，一个通常方法是使用一个变量 objects / OBJECTS / objs / OBJS / OBJ 来作为所有.o文件的列表的替代

一般在 makefile 中执行伪目标的时候，都会利用 .PHONY 来声明，尽管只使用 clean: 也是正确的
  .PHONY : clean 
    clean : 
    -rm edit $(objects)
  
  clean:
    rm edit $(objects)

第一种方式有两点不同：
  1、通过 .PHONY 特殊目标将 clean 目标声明成伪目标。防止当磁盘磁盘上出现一个名为 clean 文件时，clean 所在规则的
      命令无法执行
  2、在命令之前使用 - ，意思是忽略命令 rm 的执行错误



////////////// makefile 总述 //////////////
通常指示符 "include" 用在以下场合:
  1、有多个不同的程序，由不同目录下的几个独立的 Makefile 来描述其创建或者更新的规则。它们需要使用一组通用的变量定义
    或者模式规则。通常做法就是将这些共同使用的变量或者模式规则定义在一个文件中(没有具体的文件命名限制)，在需要使用的
    Makefile 中使用指示符 "include" 来包含此文件
  2、当根据源文件自动产生依赖文件时； 我们可以将自动产生的依赖关系保存在另外一个文件中，主 Makefile 使用指示符 "include"
    包含这些文件。这样的做法比直接在主 Makefile 中追加依赖文件的方法要明智的多。其他版本的 make 已经使用这种方式来处理了

  -include 则会忽略由于包含文件不存在或者无法创建时的错误提示。为了和其他 make 程序兼容，也可以使用 sinclude


变量 MAKEFILES
  如果当前环境中定义了一个 MAKEFILES 的环境变量，make 执行时首先将此变量的值作为需要读入的 Makefile 文件，多个文件之间
使用空格分开。如果文件名非绝对路径而且当前目录也不存在此文件，make 会在一些默认路径去寻找。与 include 类似，但两者的区别：
  1、环境变量指定的 makefile 文件中的 "目标" 不会被作为 make 执行的 "终极目标"。而如果在 make 工作目录下存在 Makefile
    文件，该文件中所定义的目标就是 make 执行时的 "终极目标"
  2、环境变量所定义的文件列表，如果在 make 执行时找不到某个文件，make 不会提示错误，也不会退出
  3、make 执行时，首先读取的是环境变量 "MAKEFILES" 所指定的文件列表，之后才是工作目录下的 makefile，include 包含的文件

  MAKEFILES 主要用于在 make 递归调用过程中的通信，实际应用中很少使用。因为一旦设置了此变量，在多层 make 调用时，每一级
make 都会读取该变量中所指定的文件，这样可能导致执行时的混乱。不过，我们可以使用该变量来指定一个定义通用的 "隐含规则" 和用的
变量的文件，比如设置默认搜索路径；通过这种方式设置的 "隐含规则" 和定义的变量可以被任何 make 进程使用
  推荐的做法还是在需要包含其他 makefile 文件时使用 include 来实现