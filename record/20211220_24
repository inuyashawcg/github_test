////////////// 20211220 //////////////
  目前文件树的构建还是建立在 tptfs 层级之下的，这就会导致只有 tptfs 下的文件节点会被注册到 Global Registry 当中，
devfs 下的设备文件节点仍然是非注册状态。解决方式也有两种，第一种就是为每一个需要注册节点的文件系统都设计一套File class，
这显然是不行的；另外一种就是创建一个类似于 vnode 的 file class，这样就可以把所有类型的文件节点都进行包装，这样做比较
合适的。
  vnode 是一个动态创建的数据结构，不能作为 GR entry，因此我们需要的可以认为是一个静态 vnode 类。所以，在 vnode 层添加
一个 class VFile 作为所有文件的节点类，每个文件系统文件节点类都继承于该类，然后实例化。因为 VFS 层级不会进行具体文件的
创建，所以只能在文件系统中添加注册功能。因此，文件注册机制实现不了一劳永逸，每种类型的文件系统都要做相应的修改

  对于文件节点的查找可以分成两个步骤：
    1、通过 key 判断是否有相应的节点存在，如果有的话，就直接调用对应文件系统的一些功能函数将 vnode，inode 和 class filenode
      建立映射关系
    2、如果没有找到对应的文件节点，那就还是按照 vfs 的实现逻辑一层一层进行文件查找

  vfs 层级对于文件的查找会设置一些模式，比如我们可以通过 sysctl 来设置是否支持 .. 处理 (路径中出现了 .. 是否会被解析)。或者也可以
设置是否仅仅支持相对路径查找。分别对应宏 NI_LCF_CAP_DOTDOT / NI_LCF_STRICTRELATIVE

  修改 vfs 实现需要注意的点：
    1、nameidata 属性设置尽量保持跟原有逻辑一致
    2、vnode 申请和释放过程中是否要加锁解锁


////////////// 20211221 //////////////
  vfs namei 函数代码感觉是不需要修改的，因为它所提供的就是路径信息。链接文件的话会把链接文件中存储的信息读取出来，放到 componentname
结构体当中，继续循环访问

  tptfs 下挂载其他文件系统时有可能出现路径重复的问题，比如说 tptfs 下有一个文件 /ext2/a，当我把一个 ext2 格式的磁盘挂载到该目录下的时候，
里边也恰巧有一个a文件，这就会造成路径重复问题。因为通过绝对路径查找它得到的输入信息就是一个路径，我们也不知道其中到底有没有其他文件系统的挂载点。
  解决方法就是我们可以对文件系统的挂载路径进行限定，比如 devfs 的挂载路径就是 /devfs，磁盘文件系统只能挂在到假设/other 路径下。这样在我们
进行路径解析的时候，只要匹配到这些字符串，那就按照原有 lookup 机制执行，否则就是通过 GR 查找


////////////// 20211222 //////////////
  tptfs 目前采用的 mount 的时候创建根节点会有一个问题，每次 mount 都会重新 new 一个根节点，之前加载的文件就会消失。正确的做法应该是在 vfs
初始化的时候就直接创建根节点，并且是全局唯一的。tptfs 挂载的时候要去查找这个根节点的类对象，而不应该是重新实例化一个

  vfs lookup 机制可以首先利用 Global Registry 快速查找文件是否存在。如果存在的话，就仿照原有的 vfs 的处理逻辑对 vnode、inode 等进行关联。
如果不存在，则退回到原有的模式进行操作。(路径中间可能会混有链接文件或者是挂载点，挂载点就规定挂载路径，链接文件就是把链接文件中存储的路径信息添加
到现有的搜索路径当中)

  基类中定义的虚函数A在子类中重写，实例化子类，然后用一个基类指针指向这个子类，访问到的A函数其实是子类中的那个函数，而不是基类中定义的函数。因为
在虚函数表中已经找不到基类定义的函数了，只有子类中的