- 基类中的虚函数成员在派生类中仍然是虚函数，无需特别指定，但执意加上 virtual 关键字也是可以的

- override 关键字就是告诉编译器，某个基类中的函数在子类中是要被覆盖掉的，防止由于疏忽写错函数名导致的小问题等。
  而 final 则表示某个成员函数已经到了最终版本，后续子类再对其进行


///////// 友元
- 类可以允许其他类或者函数访问它的"非公有成员"，方法是令其他类或者函数成为它的友元。如果类想要把一个函数作为它的友元，
  只需要添加一条"以 friend 关键字开始的函数声明语句即可"
- 友元声明只能出现在类定义的内部，但是"在类中出现的具体位置不限"
- "友元不是类的成员，所以也不接受它所在区域访问控制权限级别的约束"
- 一般来说，最好在类定义的起始或者结束前的位置集中声明友元
- "友元的声明仅仅指定了访问的权限，而非通常意义上的函数声明"。如果我们希望类的用户能够调用某个友元函数，则必须在友元
   声明之外再专门对函数进行一次声明
- 为了使友元对类的用户可见，我们通常把友元的声明与类本身放在同一个头文件中(类的外部)
- "许多编译器并不会强制要求必须在使用之前在类的外部定义"。不过最好还是提供一个独立的友元函数声明，这样即使更换了一个有
  这种强制要求的编译器，也无需改变代码
- "类可以把其他类(之前已经定义过的)成员函数定义成友元"
- 友元函数还可以定义在类的内部，"此时函数是隐式内联的"


///////// C++ 类构造函数 explicit
举例说明：
  class number {
  public:
    number(int num);

  private:
    int value;
  }

然后在使用的过程中，出现了如下代码:
  number a = 1;

看起来十分怪异，但是这种写法其实是被允许的，为什么？ 隐式转换机制的作用。当我们不用 explicit 关键字修饰构造函数时，
编译器会把上述代码转换成如下形式:
  number a(1);
或者
  number temp(1);
  number a = temp;
加上 explicit 关键字，可以避免这种容易让人产生疑惑的代码

- explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时,
  是不会产生隐式转换的,所以 explicit 关键字也就无效了

- 一个例外, 就是当除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效。
  此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数
