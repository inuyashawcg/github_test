- 基类中的虚函数成员在派生类中仍然是虚函数，无需特别指定，但执意加上 virtual 关键字也是可以的

- override 关键字就是告诉编译器，某个基类中的函数在子类中是要被覆盖掉的，防止由于疏忽写错函数名导致的小问题等。
  而 final 则表示某个成员函数已经到了最终版本，后续子类再对其进行


///////// 友元 /////////
- 类可以允许其他类或者函数访问它的"非公有成员"，方法是令其他类或者函数成为它的友元。如果类想要把一个函数作为它的友元，
  只需要添加一条"以 friend 关键字开始的函数声明语句即可"
- 友元声明只能出现在类定义的内部，但是"在类中出现的具体位置不限"
- "友元不是类的成员，所以也不接受它所在区域访问控制权限级别的约束"
- 一般来说，最好在类定义的起始或者结束前的位置集中声明友元
- "友元的声明仅仅指定了访问的权限，而非通常意义上的函数声明"。如果我们希望类的用户能够调用某个友元函数，则必须在友元
   声明之外再专门对函数进行一次声明
- 为了使友元对类的用户可见，我们通常把友元的声明与类本身放在同一个头文件中(类的外部)
- "许多编译器并不会强制要求必须在使用之前在类的外部定义"。不过最好还是提供一个独立的友元函数声明，这样即使更换了一个有
  这种强制要求的编译器，也无需改变代码
- "类可以把其他类(之前已经定义过的)成员函数定义成友元"
- 友元函数还可以定义在类的内部，"此时函数是隐式内联的"


///////// C++ 类构造函数 explicit /////////
举例说明：
  class number {
  public:
    number(int num);

  private:
    int value;
  }

然后在使用的过程中，出现了如下代码:
  number a = 1;

看起来十分怪异，但是这种写法其实是被允许的，为什么？ 隐式转换机制的作用。当我们不用 explicit 关键字修饰构造函数时，
编译器会把上述代码转换成如下形式:
  number a(1);
或者
  number temp(1);
  number a = temp;
加上 explicit 关键字，可以避免这种容易让人产生疑惑的代码

- explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时,
  是不会产生隐式转换的,所以 explicit 关键字也就无效了

- 一个例外, 就是当除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效。
  此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数


///////// C++左值和右值 /////////
左值的英文简写是 lvalue，其实并不是 left value 的缩写，而是 loactor(定位器) value，可意为存储在内存中、有明确存储地址（可寻址）的数据；
右值的英文简写是 rvalue，同样不是 right value，而是 read value，指的是那些可以提供数据值的数据 (不一定可以寻址，例如存储于寄存器中的数据)

1) 可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。举个例子：
  int a = 5;
  5 = a; //错误，5 不能为左值

其中，变量 a 就是一个左值，而字面量 5 就是一个右值。值得一提的是，C++ 中的左值也可以当做右值使用，例如：
  int b = 10; // b 是一个左值
  a = b; // a、b 都是左值，只不过将 b 可以当做右值使用

2) 有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。
以上面定义的变量 a、b 为例，a 和 b 是变量名，且通过 &a 和 &b 可以获得他们的存储地址，因此 a 和 b 都是左值；
反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），
因此 5、10 都是右值

C++右值引用
前面提到，其实 C++98/03 标准中就有引用，使用 "&" 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，
无法对右值添加引用。举个例子：
  int num = 10;
  int &b = num; //正确
  int &c = 10; //错误
如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98/03 标准中的引用又称为左值引用

注意，虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，
也可以操作右值，例如：
  int num = 10;
  const int &b = num;
  const int &c = 10;
我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改
(实现移动语义时就需要)，显然左值引用的方式是行不通的。为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 "&&" 表示。
话说，C++标准委员会在选定右值引用符号时，既希望能选用现有 C++ 内部已有的符号，还不能与 C++ 98 /03 标准产生冲突，最终选定了
2 个 '&' 表示右值引用

需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：
  int num = 10;
  //int && a = num;  //右值引用不能初始化为左值
  int && a = 10;
和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：
  int && a = 10;
  a = 100;
  cout << a << endl;
程序输出结果为 100

另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如：
  const int&& a = 10;//编译器不会报错 
但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；
其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成


///////// 异常处理 throw try catch /////////
  http://c.biancheng.net/cplus/exception/

  try 用来检测有没有异常发生，如果有的话，交给 catch 来处理。这里有一个前提条件，就是我们处理的代码要能够"扔出"异常，
try 才有能力捕获到这个异常。假如我们所写的代码根本就没有"扔出"这个功能，即使套上 try catch，仍然不会触发异常操作


C++ 基类应该是各个子类方法和成员的交集，而不应该是并集