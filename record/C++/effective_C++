////////////////////////////////
条款2 - 尽量以 const / enum / inline 替换 #define （“宁可以编译器替换预处理器”）

作者举例，假如代码中出现了下面的一行：
  #define ASSERT_RATIO 1.653

  ASSERT_RATIO 可能在预处理阶段就会被替换掉，这就会导致编译器可能根本就不知道还存在这么一个记号名称。
自然而然，它也就没有进入到符号表当中。
  再然后，可能我们的代码中某个地方用到了这个常量，但是用错了。此时编译器会给我们报错误信息，那么其中
可能只有 1.653，而没有这个记号。假设它又刚好在别人所写的头文件中，那我们会更加困惑这个错误到底是怎么
来的。
  解决的办法就是，用一个常量替换上述的宏定义。这个的话个人认为也要分情况考虑，如果一个常量仅仅是在自己
负责的模块当中使用，并不会用到其他的地方，宏定义也是可以用的。
  const double AspectRatio = 1.653;

使用常量可能会比使用宏定义产生更小的代码量，因为宏定义可能会被多次替换。

方法宏用 inline 进行替换，不论是类成员函数还是全局函数
  #define CALL_WITH_MAX(a, b) f((a) > (b) ? (a) : (b))

这类宏一定要为所有的参数加上小括号，否则有可能在调用的时候遇到一些意向不到的问题。但即使是这样，还是可能
会遇到一些不可思议的事情，比如:
  int a = 5, b = 0;
  CALL_WITH_MAX(++a, b);      // a 被累加2次
  CALL_WITH_MAX(++a, b+10);   // a 被累加1次

在这里，调用f之前，a的递增次数竟然取决于 "它被拿来和谁比较"。解决这个问题的方法就是利用 inline 函数去替代
  template<class T>
  inline void callWithMax(const T& a, const T& b) {
    f(a > b ? a : b);
  }

>>> 请记住
- 对于单纯常量，最好以 const 对象或者 enums 替换 #define
- 对于形似函数的宏，最好改用 inline 函数替换 #define


////////////////////////////////
条款3 - 尽可能使用 const
  const 其实就是一个语义约束，也就是执行一个“不该被改变”的对象，而编译器会强制实施这项约束。它允许你告诉
编译器和其他程序员某值应该保持不变。意思就是说，当我们在编程的过程中确认某个值在某些操作中是不会被改变的，
那么我们就应该利用 const 对其进行限定

  令函数返回一个常量值，往往可以降低客户错误而造成的意外，而又不至于放弃安全性和高效性。举个例子，考虑
有理数类(rational numbers) 的 operator* 声明式:
  class Rational {...};
  const Rational operator* (const Rational& lhs, const Rational& rhs);

  为什么要返回一个 const 对象？ 考虑如下情况:
  Rational a, b, c;
  ...
  if (a * b = c);  // 在 a * b 的成果上调用 operator=

本来只是想做比较操作，可能由于编码时候的疏忽，写成了赋值操作。假如 a 和 b 都是内置类型，这样的代码直截了当
就是不合法的。一个 "良好的用户自定义类型" 的特征就是它们要避免无端地与内置类型不兼容。这就话就说明，当用户
自定义一个数据类型的时候，它的一切行为都应该向内置类型看齐。内置类型允许的操作，它应该支持；内置类型不允许
的操作，它肯定也要禁止。所以，将 operator* 的返回值声明为 const 可以预防那个 "没意义的赋值操作"

  non-const 成员函数可通过调用 const 成员函数减少代码重复
  class TestBlock {
  public:
    ...
    const char& operator[](std::size_t position) const {
      ...
      return text[position];
    }

    char& operator[](std::size_t position) {
      return const_cast<char&>(   // 将 op[] 返回值的 const 移除
          static_cast<const TestBlock&>(*this)  // 为 *this 加上 const
            [position]                          // 调用 const op[] 
        );
    }
    ...
  };

>>> 请记住
- 将某些东西声明成 const 可以帮助编译器检查出错误用法。const 可被施加于任何作用域内的对象、函数参数、函数
  返回类型、成员函数本体
- 编译器强制实施 bitwise constness，但程序员编写程序时应该使用"概念上的常量性(conceptual constness)"
- 当 const 和 non-const 成员函数实质等价地实现时，令 non-const 版本调用 const 版本可避免代码重复


////////////////////////////////
条款4 - 确定对象被使用前已先被初始化
  C++ 对于 "将对象初始化" 这件事，总是表现的反复无常。假如我们这么写:
    int x;
    class Point {
      int x, y;
    };
    ...
    Point p;

在某些语境下，x 和 p 的成员变量会被初始化为0，但有时候并不会。最佳的处理办法就是: 永远在使用对象之前先将它
初始化。对于无任何成员的内置类型，我们必须手工完成此事。例如:
  int x = 0;
  const char* text  = "A C-style string";

  double d;
  std::cin >> d;

  对于内置类型之外的任何其他东西，初始化责任落在构造函数身上。规则很简单: "确保每一个构造函数都将对象的每一个
成员初始化"。这里我们要注意赋值与初始化的区别:
  - C++ 规定，对象成员变量的初始化动作发生在进入构造函数本体之前
  - default 是否也是需要对每个类成员进行初始化？

也就是说，构造函数本体之内的都算做是赋值行为，而不是初始化。列表初始化是一种比较好的做法，虽说与赋值操作得到的
结果是一致的，但通常效率较高。基于赋值的版本首先是调用 default 构造函数给成员变量赋初值，然后再立刻对它们赋予
新值，结果就是 default 构造函数所做的一切都因此浪费了。

  如果一个 class 拥有多个构造函数，每个构造函数都有自己的成员初值列。如果刚好这种 class 存在许多成员变量或者
base classes，多份成员初值列的存在就会导致不受欢迎的重复和无聊的工作。这种情况下可以合理地在初值列中遗漏那些
"赋值表现像初始化一样好" 的成员变量，改用它们的赋值操作，并将这些赋值操作转移到某个函数 (通常是 private),
供所有的构造函数调用。这种做法在 "成员变量的初值由文件或者数据库读入" 时特别有用

  C++ 有着十分固定的 "成员初始化次序":
    - base classes 更早于 derived classes 被初始化，class 成员变量总是以其声明次序被初始化
所以，构造函数初值列的次序最好按照以上顺序进行，但应该影响不大。

  假如我们把上面提到的这些都做好了，那就只剩唯一一件事情需要操心: "不同编译单元内定义之 non-local static 对象
的初始化次序"。
  所谓 static 对象，其寿命从被构造出来直到程序运行结束，因此 stack 和 heap-based 对象都被排除。这种对象包括
global 对象、定义于 namespace 作用域内的对象、在 classes 内、在函数内、以及在 file 作用域内被声明为 static 
的对象。
  编译单元(translation unit)： 是指产出单一目标文件的那些源码
假设一个编译单元内的某个 non-local static 对象的初始化动作使用到了另外一个编译单元内的某个 non-local static
对象，它所用到的这个对象很可能尚未被初始化。用户也要保证不同编译单元的初始化次序也是正确的

>>> 请记住
  - 为内置类型对象进行手工初始化，因为C++不保证初始化它们
  - 构造函数最好使用成员初始值列(member initialization list)，而不要在构造函数本体内使用赋值操作(assignment)。
    初值列列出的成员变量，其排列顺序应该和它们在 class 中的声明次序相同



////////////////////////////////
条款5 - 了解C++默默编写并调用哪些函数
  当我们写一个 empty class 的时候，C++ 会默默帮助我们把它扩展成另外一个版本：
    class Emtry {}；
        ||
        ||  C++
        \/
    class Empty {
    public:
      Empty() {...}                             // default 构造函数
      Empty(const Empty& rhs) {...}             // copy 构造函数
      ~Empty() {...}                            // 析构函数，默认是非虚的，除非基类是 virtual

      Empty& operator=(const Empty& rhs) {...}  // copy assignment操作符
    }

>>> 请记住
  - 编译器可以暗自为 class 创建 default 构造函数、拷贝构造函数、copy assignment操作符，以及析构函数



////////////////////////////////
条款6 - 若不想使用编译器自动生成的函数，就要明确拒绝
  假设用户是一位真正的地产商人，那么他绝对会说任何一个房屋都是天下独一无二的。如果开发者要为房子设计一个类，
那为实例对象做一份副本有点没道理。因此，开发者应该会乐意看到类对象拷贝动作以失败收场。通常我们不希望 class
支持某种特定机能的时候，只要不声明对应的函数就是了。但是这个策略对于 copy 构造函数和 copy assignment
操作符却不起作用。就算是我们不声明它们，而某些人尝试调用它们，编译器会声明它们。

  答案的关键是，所有编译器产出的函数都是 public。因此，我们可以将 copy 构造函数或者 copy assignment
操作符声明为 private。许多C++标准库的代码实现中使用了这种方法：将它们声明成 private 并且没有任何实现。

  通常不会直接将目标类的 copy 构造函数和 copy assignment操作符 声明成 private，而是专门设计一个为了
阻止 copying 动作而设计的 base class：
  class Uncopyable {
  protected:
    Uncopyable() {}         // 允许 derived 对象构造和析构
    ~Uncopyable() {}
  
  private：
    Uncopyable(const Uncopyable&);            // 但阻止 copying
    Uncopyable& operator=(const Uncopyable&);
  }；

  class HomeForSale : private Uncopyable {
    ...
  };

>>> 请记住
  - 为驳回编译器自动 (暗自) 提供的机能，可将相应的成员函数声明为 private 并且不予实现。使用像 Uncopyable
    这样的基类也是一种做法