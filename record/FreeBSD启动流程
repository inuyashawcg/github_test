启动流程

	1. FreeBSD默认的内核可执行程序镜像位于根文件系统的一个名为/boot/kernel/kernel中，系统运行其实就是将该文件加载到内存当中

	2. 一般情况下，在主磁盘起始位置的一块保留区域内都会放置一个小的引导程序，这个引导程序通常会被限制到很小的一块区域以内（512个字节的一个磁盘扇区那么大），并且将一个更大的程序从紧随其后的磁盘位置加载进来

	3. 引导程序的作用通常是用来载入并运行一个名为boot的特殊程序的，而boot程序的任务就是载入和初始化一个程序的可执行镜像，并让它运行起来。boot可能位于和它所引导的文件相同的存储设备上，或者从一台网络服务器载入

	4. boot程序启动之后，它就开始载入/boot/kernel/kernel镜像，然后开始计数，期间用户可以中断计数来进行相关的调试，然后再load kernel镜像

	5. FreeBSD中久内核被存放并命名为 /boot/kernel/kernel.old

	6. boot程序把内核载入到内存当中之后，内核也要经历几个初始化阶段。首先就是设置CPU的初始状态，包括运行栈和虚拟内存的映射。
	在系统启动过程的开始就要启动内存映射，包括虚拟地址的转换，从而把移植内核所必须要写的汇编代码减到最小

	7. 一旦启动了虚拟内存映射，系统就将进行与机器相关的操作，然后是与机器无关的操作。与机器相关的操作包括建立虚拟内存页表和配置IO设备（驱动程序的加载是在根文件系统安装之前？？）；与机器无关的操作包括安装根文件系统，并初始化各种数据结构。必要时按照这个顺序，因为许多与机器无关的初始化操作需要依赖IO设备的正确的初始化

	8. 当内核完成与机器无关的初始化部分之后，系统便处于运行状态了，然后就是创建系统进程。从文件系统中载入用户级程序并运行，这个时候系统就可以运行普通的应用程序了


引导与初始化内核
	
	1. 引导程序是一个与机器相关的操作，在很过机器上都是由BIOS（Basic Input/Output System，基本的输入输出系统）来完成。BIOS存储在一个非易失性的存储设备当中，当CPU复位的时候自动调用。BIOS提供的功能要支持引导独立的程序。大多数BIOS也支持机器在复位时候的诊断操作，以保证硬件正常工作

	2. BIOS并不能理解FreeBSD文件系统格式，他所作的工作主要就是读取位于启动磁盘上的一个保留区域内的程序，最终的结果就是执行FreeBSD的boot程序，然后就是boot把内核启动起来

	3. boot在启动内核之前，需要对其进行初始化操作，大致分为三个阶段：
		- 利用汇编代码编写的程序设置硬件，完成运行更通用的非汇编语言代码所必须的工作
		- 载入并初始化内核模块，这些模块实现了内核的全部内部服务，包括配置和初始化机器上的IO设备
		- 启动驻留系统的进程，他们构成了常规FreeBSD运行环境的基础，然后执行用户级的启动脚本

		系统初始化的第一步通过汇编代码完成，这项工作与机器高度相关，主要包括:
			- 设置运行时的堆栈
			- 识别系统的CPU类型
			- 统计机器上的物理内存的数量
			- 启动虚拟地址转换硬件
			- 初始化内存管理硬件
			- 如有需要，创建SMP操作表
			- 创建0号进程的硬件上下文（context）
			- 调用初始的基于C语言的系统入口

		boot程序使FreeBSD内核开始运行时，它只建立齐了机器状态的两个部分:
			- 屏蔽所有的中断
			- 禁止硬件地址转换功能，所有的内存存取都是在物理地址上进行的


初始化内核模块

	FreeBSD在初始化内核模块上采用了一中设计方法：将所有的内核服务分成若干个模块，在内核引导的时候按逻辑上的次序加载，这样就使得向内核添加新的模块变得更加容易。文件 /sys/sys/kernel.h中列出了所有的子系统。

	FreeBSD使用的内核模块分为两种：
		- 可加载模块：能够在系统运行的时候动态加载和卸载
		- 永久性模块：必须要系统引导的期间就加载，而且一旦加载后就不允许再被卸载
	SYSINT这个宏可以把永久性模块提供给系统，它确定了模块的名称，初始化例程和应该调用的顺序

	SYSINT(name， subsystem， order, function, identifier)
	所有的模块组成了一种让系统能够按顺序启动的两级结构:
		- subsystem是这个层次中的第一级。每个子系统都有一个特殊的数字常量，它确定了模块在第一级里的加载顺序
		- order构成了第二级的顺序。如果两个模块都在同一个子系统中，那么order将决定哪个模块首先被加载
		- function是内核在系统启动时调用的初始化函数

	汇编语言完成了它的工作之后，调用的第一个C语言内核例程是mi_startup()，该函数会把一系列的内核模块进行排序，然后各个模块调用自己的函数例程。因为这些模块有的是与机器相关的，有些则是与机器无关的，先把机器相关的例程完成之后，再去执行机器无关的例程，这样就把机器相关跟无关的工作分开了。


基本服务

	FreeBSD在做任何工作以前，都需要配置一些基本的服务，内核中的所有子系统都要使用它们，包括互斥支持，锁管理器，内核内存管理等等。所以这也就决定了内核模块的启动顺序，这些基本的服务都是要优先初始化，这样后边的模块才可以使用相应的服务。（文档中与实际的代码有出入，这里先以文档为主，实际使用时要对照源代码来看）内核模块彼此之间的紧密依赖性很强，所以改变内核模块加载顺序的时候要特别小心

			模块                             对应的第一个例程

	- SI_SUB_MTX_POOL_STATIC			mtx_pool_setup_static()

	- SI_SUB_LOCKMGR					lockrngr_init()

	- SI_SUB_VM							vm_mem_init()

	- SI_SUB_KMEM						kmeminit()

	- SI_SUB_KVM_RSEC					vmrnapentry_rsrc_init()

	- SI_SUB_WITNESS					witness_initialize()

	- SI_SUB_MTX_POOL_DYNAMIC			mtx_pool_setup_dynamic()

	- SI_SUB_LOCK 						selectinit()

	- SI_SUB_EVENTHANDLER				eventthandler_init()

	- SI_SUB_KLD						linker_init()

	- SI_SUB_CPU						cpu_startup()

	vm_mem_init() 启动虚拟内存系统，该函数在完成例程中的工作之后，内核或者进程的全部内存分配工作就要按照虚拟地址来进行，然后内存管理硬件把虚拟地址转化成物理地址

	内存子系统初始化的最后一步要给内核虚拟存储系统使用的资源权限，vmrnapentry_rsrc_init()来完成此项工作，之后内核模块就可以通过内核malloc()来申请内存了

	要把单处理器内核转换成支持SMP内核，就要利用在内核的数据结构上使用锁机制，以免在多个相互独立的线程间发生冲突。FreeBSD增加了一个内核库，它可以监视所有的持锁和解锁的情况。witness_initialize()把SI_SUB_WITNESS模块作为一个基本的服务来启动，能够向需要处理上锁机制的模块提供witness库

	有些服务需要在基本服务中就分配锁，这个时候就要使用到SI_SUB_LOCK，实现机制大致就是一个注册，注册好了之后，就表明该服务需要在启动的过程中调用锁的初始化例程

	event-handler模块就是管理各种服务的注册，一旦某个事件发生，内核就调用相应的函数


初始化内核线程

	内核有几个要在引导的时候就建立的线程，而内核运行的过程中也必须要有这些进程

			内核进程模块						第一个例程

		- SI_SUB_INTRINSIC				proc0_init()

		- SI_SUB_VM_CONF				vm_init_limits()

		- SI_SUB_RUN_QUEUE				runq_init()

		- SI_SUB_KTRACE					ktrace_init()

		- SI_SUB_CREATE_INIT			create_init()

		- SI_SUB_SCHED_IDLE				idle_setup()

	内核一旦运行起来之后，就要从一个现有的进程派生出所有的新进程。由于系统在第一次启动的时候一个进程都没有，所以启动代码必须要做出来第一个进程，就是swapper进程。它的PID为0，在汇编语言的启动代码中就已经开始建立这个进程，但是一直到这个时候系统才有足够的服务来完成这项工作proc0_init()不仅要建立进程0，而且还要初始化所有用于进程和线程处理、文件描述符表的全局数据结构，并且还要对这些数据结构加以限制。proc0_init()例程还要创建一个虚拟内存映射的原型，它将作为最终创建的其他进程的原型。

	初始化完swapper进程的数据结构之后，系统紧接着就要通过调用create_init()例程来创建init进程。因为init进程紧挨着swapper进程，所以init的PID为1，这样也就方便特权用户同init进程通信（因为不需要去查init进程的PID）

	系统中的每个CPU都有一个idle进程，该进程的主要任务就是当CPU没有工作要去干的时候暂停CPU。一旦swapper进程和init进程建立之后，系统就要为每一个CPU建立一个idle进程。该进程同其他内核进程一样，idle进程刚创建的时候也不会启动


初始化设备模块

	当内核的基本服务和基本进程都创建完成之后，接着就可以对系统内剩下的设备进程初始化了，包括磁盘，网口，时钟等等

			模块							第一个例程

		- SI_SUB_MBUF				mbuf_init()

		- SI_SUB_INTR 				intr_init()

		- SI_SUB_SOFTINTR			start_softintr(), start_netisr()

		- SI_SUB_DEVFS				devry_init(), devs_set_ready()

		- SI_SUB_INIT_IF			if_init()

		- SI_SUB_DRIVERS			many different routines

		- SI_SUB_CONFIGURE			configure_first()

		- SI_SUB_VFS 				vfsnit()

		- SI_SUB_CLOCKS 			initclocks()

		- SI_SUB_CLIST				clist_init()

	能够对任何设备，尤其是网络接口进行初始化之前，必须要建立mbuf系统，好让网络接口有一组缓冲，他们可以在自己的初始化过程中使用这些缓冲。SI_SUB_MBUF模块和mbuf_init()例程就是负责处理mbuf子系统的初始化工作

	启动过程进行到这里，系统尚未启动硬件中断。内核现在建立了所有的中断线程来处理系统开始运行时的中断，主要由两个模块来实现: SI_SUB_INTR模块创建处理设备中断的中断线程，SI_SUB_SOFTINTR模块创建软中断，软中断线程可以供处理异步事件的服务使用，但这些中断并不是由硬件产生的。

	启动实际的硬件设备时，系统首先要对设备文件系统进行初始化，然后调用if_init()例程让网络栈做好处理设备的准备。if_init()不对任何网络接口进行初始化，它仅仅是建立支持它们的数据结构。最后再由SI_SUB_DRIVERS和SI_SUB_CONFIGURE两个模块进行初始化操作

	一旦配置好了所有的设备，就要对虚拟文件系统进行初始化

	接着建立的和硬件提供的实时时钟有关系，initclocks()例程是SI_SUB_CLOCKS模块的一部分，它调用针对体系结构的cpu_initclocks()例程，初始化系统上的硬件时钟，并且让他们开始运行。硬件时钟运行起来之后，像NTP，设备轮询，事件计数器等类似的服务就可以启动起来了。SI_SUB_CLIST模块用来在最后初始化在终端子系统中的数据结构，基本操作是首先分配一组cblock，然后把它们加载到clist当中


内核可加载模块

	DECLARE_MODULE(name, data, subsystem, order)



启动内核线程



用户级初始化