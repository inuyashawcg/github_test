//////////////
ext2_htree.c - ext2_htree_create_index():
    line: 738
    TODO: DOINGASYNC 宏貌似是跟线程同步相关的操作，讨论是否需要进一步处理

//////////////
很多地方省略了对checksum的操作，后续要考虑是否添加上

//////////////
    目录项大小的宏定义需要修改 TPT_DIR_REC_LEN，并且目录项的大小其实不是固定不变的，而是可以动态变化的。所以，不同
引用场合下的处理也要区分开来，而不是全部都设置为256

//////////////
ext2_lookup.c - ext2_lookup_ino():
    namei cache 的相关操作

//////////////
tptfs_lookup.cpp - TptDirBad()
    SDT_PROBE4: 
        当添加 extern "C" 的时候:
        /usr/home/wcg/qihai/sys/fs/tptfs/tptfs_lookup.cpp:58:12: error: expected unqualified-id
            extern "C" {
        
        当不添加 extern "C" 的时候:
        ld: error: undefined symbol: sdt_provider_tptfs
        >>> referenced by tptfs_lookup.cpp
        >>>               tptfs_lookup.o:(sdt_tptfs__lookup_trace)
        >>> referenced by tptfs_lookup.cpp
        >>>               tptfs_lookup.o:(sdt_tptfs__trace_tpt_dirbad_error)
        >>> referenced by tptfs_lookup.cpp
        >>>               tptfs_lookup.o:(sdt_tptfs__trace_tpt_dirbadentry_error)
        *** [kernel.full] Error code 1

//////////////
tptfs 中的 uio 相关操作的替换

//////////////
newtpt 初始化数据块的操作(htree)

//////////////*****
利用编译器对文件进行静态关联。需要研究一下编译器查找方面的一下功能以及 fopen 等系统函数的行为，因为修改之后可能就是
对虚拟地址的操作，而不再通过文件描述符。所以还要再去看一下进程描述符表相关知识

//////////////
bread() 函数的行为

//////////////
文件系统中数据大小的扩展。比如 ext4 中数据块总个数是用一个64位的整型数据表示的，目前还是以32位来表示。
后续要看文件系统的规模会有多大，根据情况再进行数据位扩展。tptfs 留给超级块的空间是足够的，这些扩展没有
太大问题

//////////////
移植 ext2_alloc.c 中的函数时，省略掉了一些 SDT_PROBE* 和 SYSCTL 相关的定义

//////////////
ext2_alloc.c - ext2_alloccg() 函数的参数中有一个 bpref，这个表示的貌似是绝对块号，要注意处理方法

//////////////
TptInodeOps::TptInactive() 函数中的 extattr free 操作暂时省略，后续需要添加

//////////////
TptIndTruncate 函数中的 newblock 操作

//////////////
文件系统的相对块号和虚拟页号的计算要进行区分

//////////////
调研一下目录项查找块中的 . 和 .. 的长度是否都要是256，还是说 .. 的长度要设置为 blocksize - 256

//////////////
源代码与文件系统的关系是什么样的

//////////////
    未来 tptfs 要将跟人的交互与系统内部的交互区分开来，跟人的交互完全可以按照现有的模式来，但是系统内部的
信息交互大概率是要借助 global registry

//////////////
htree entry 初始化的时候是全部赋值为0，还是将 block count 初始化为1

//////////////
对于一些文件系统属性的判断，现在还没有处理(比如 lookup 过程中判断文件系统是否支持 hash index等)

//////////////
TptNodeAlloc() 函数中对于 TPT_INODE_UNINIT 情况暂时未处理

//////////////
    TptNodeAlloc 函数中会调用多次 TptGetNiFree 函数，防止在一个线程访问的时候刚好另外一个线程进行了抢占，
把最后一个 inode 给申请掉了。但是这个感觉应该是读取磁盘等待的时候才会发生的，如果都是在内存中的话，应该是不会
发生类似的事情的。需要讨论一下

//////////////
TptMakeDir 函数中 tail 和 checksum 的处理

//////////////
之前调试中遇到的一些锁操作有可能是一些过程中代码错误导致的

//////////////
htree 中的 malloc 处理，尤其是 TptHtreeAddEntry 函数，比较复杂

//////////////
TptGetPages 手动修改数据页属性


- 硬链接如何处理？
