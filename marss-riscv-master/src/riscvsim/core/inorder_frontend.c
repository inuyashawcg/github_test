/*
 * In-order Pipeline Front-end Stages: pcgen, fetch and decode
 *
 * Copyright (c) 2016-2017 Fabrice Bellard
 *
 * MARSS-RISCV : Micro-Architectural System Simulator for RISC-V
 *
 * Copyright (c) 2017-2020 Gaurav Kothari {gkothar1@binghamton.edu}
 * State University of New York at Binghamton
 *
 * Copyright (c) 2018-2019 Parikshit Sarnaik {psarnai1@binghamton.edu}
 * State University of New York at Binghamton
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#include "inorder.h"
#include "../../riscv_cpu_priv.h"
#include "../bpu/bpu.h"
#include "../utils/circular_queue.h"
#include "riscv_sim_cpu.h"

/*===========================================
=            PC Generation Stage            =
===========================================*/

void
in_core_pcgen(INCore *core)
{
    InstructionLatch *e;
    RISCVCPUState *s;

    s = core->simcpu->emu_cpu_state;
    if (core->pcgen.has_data)
    {
        if (!core->pcgen.stage_exec_done)
        {
            if (core->simcpu->skip_fetch_cycle)
            {
                /* This is a branch miss prediction redirect, so skip this cycle
                 * and fetch this new target from next cycle */
                core->simcpu->skip_fetch_cycle = FALSE;
                ++core->simcpu->stats[s->priv].pipeline_flush;
                return;
            }

            /* Calculate current PC*/
            s->simcpu->pc
                = (target_ulong)((uintptr_t)s->code_ptr + s->code_to_pc_addend);

            /* Allocate a latch for this instruction from insn_latch_pool */
            e = insn_latch_allocate(s->simcpu->insn_latch_pool);

            /* Setup the allocated latch */
            e->ins_dispatch_id = core->ins_dispatch_id++;
            e->ins.pc = s->simcpu->pc;
            e->ins.create_str = s->sim_params->create_ins_str;

            /* Store latch index in the stage and the actual decoded instruction
             * info is stored in this insn_latch_pool entry.
             * NOTE: This avoids copying of whole decoded instruction info when
             * instruction flows to next stage */
            core->pcgen.insn_latch_index = e->insn_latch_index;
            core->pcgen.stage_exec_done = TRUE;
        }

        /* If next stage is free, pass this instruction to the next stage, else
         * stall */
        if (!core->fetch.has_data)
        {
            core->pcgen.stage_exec_done = FALSE;
            core->fetch = core->pcgen;
            core->pcgen.insn_latch_index = -1;
        }
    }
}

/*=====  End of PC Generation Stage  ======*/

/*===============================================
=            Instruction Fetch Stage            =
===============================================*/

void
in_core_fetch(INCore *core)
{
    InstructionLatch *e;
    RISCVCPUState *s;

    s = core->simcpu->emu_cpu_state;
    if (core->fetch.has_data)
    {
        e = get_insn_latch(s->simcpu->insn_latch_pool,
                           core->fetch.insn_latch_index);
        if (!core->fetch.stage_exec_done)
        {
            fetch_cpu_stage_exec(s, e);
            if (e->ins.exception)
            {
                /* Stop pcgen stage and save exception context */
                cpu_stage_flush(&core->pcgen);
                sim_exception_set(s->simcpu->exception, e);
            }
            core->fetch.stage_exec_done = TRUE;
        }
        else
        {
            e = get_insn_latch(s->simcpu->insn_latch_pool,
                               core->fetch.insn_latch_index);
        }

        if (e->elasped_clock_cycles == e->max_clock_cycles)
        {
            /* Simulation of cache lookup delay for data/instruction and
             * page-table entries is complete at this point. Now request the
             * memory controller to start simulating the delay for any DRAM
             * requests generated by this cache lookup */
            if (s->simcpu->mem_hierarchy->mem_controller
                    ->frontend_mem_access_queue.cur_size
                && !e->cache_lookup_complete_signal_sent)
            {
                mem_controller_cache_lookup_complete_signal(
                    s->simcpu->mem_hierarchy->mem_controller,
                    &s->simcpu->mem_hierarchy->mem_controller
                         ->frontend_mem_access_queue);
                e->cache_lookup_complete_signal_sent =  TRUE;
            }

            /* Wait on memory controller callback for any pending memory
             * accesses */
            if (!s->simcpu->mem_hierarchy->mem_controller
                     ->frontend_mem_access_queue.cur_size)
            {
                /* Stop fetching new instructions on a MMU exception */
                if (e->ins.exception)
                {
                    cpu_stage_flush(&core->fetch);
                }
                else
                {
                    /* No MMU exception, it is safe to pass instruction to
                     * decode stage */
                    if (!core->decode.has_data)
                    {
                        s->simcpu->mem_hierarchy->mem_controller
                            ->frontend_mem_access_queue.cur_idx
                            = 0;

                        core->fetch.stage_exec_done = FALSE;
                        e->max_clock_cycles = 0;
                        e->elasped_clock_cycles = 0;
                        core->decode = core->fetch;
                        cpu_stage_flush(&core->fetch);
                    }
                }
            }
            else
            {
                ++s->simcpu->stats[s->priv].insn_mem_delay;
            }
        }
        else
        {
            e->elasped_clock_cycles++;
        }
    }
}

/*=====  End of Instruction Fetch Stage  ======*/

/*================================================
=            Instruction Decode Stage            =
================================================*/

static void
read_int_operand(const INCore *core, int has_src, int *read_rs, int rs,
                 uint64_t *buffer, int *reg_file_read_done)
{
    int i;

    if (has_src && !(*read_rs))
    {
        if (!core->int_reg_status[rs])
        {
            for (i = 0; i < NUM_FWD_BUS; ++i)
            {
                if (core->fwd_latch[i].valid && core->fwd_latch[i].int_dest
                    && (core->fwd_latch[i].rd == rs))
                {
                    *buffer = (target_ulong)core->fwd_latch[i].buffer;
                    *read_rs = TRUE;
                    break;
                }
            }
        }
        else
        {
            *buffer = (target_ulong)core->simcpu->emu_cpu_state->reg[rs];
            *read_rs = TRUE;
            *reg_file_read_done = TRUE;
        }
    }
}

static void
read_fp_operand(const INCore *core, int has_src, int *read_rs, int rs,
                uint64_t *buffer, int *reg_file_read_done)
{
    int i;

    if (has_src && !(*read_rs))
    {
        if (!core->fp_reg_status[rs])
        {
            /* Floating point execution units start from ID 3 onwards */
            for (i = 3; i < NUM_FWD_BUS; ++i)
            {
                if (core->fwd_latch[i].valid && core->fwd_latch[i].fp_dest
                    && (core->fwd_latch[i].rd == rs))
                {
                    *buffer = core->fwd_latch[i].buffer;
                    *read_rs = TRUE;
                    break;
                }
            }
        }
        else
        {
            *buffer = core->simcpu->emu_cpu_state->fp_reg[rs];
            *read_rs = TRUE;
            *reg_file_read_done = TRUE;
        }
    }
}

static void
set_waw_lock_int_dest(RISCVCPUState *s, CPUStage *stage, int rd)
{
    InstructionLatch *e;

    if (stage->has_data)
    {
        e = get_insn_latch(s->simcpu->insn_latch_pool, stage->insn_latch_index);
        if (e->ins.has_dest && (e->ins.rd == rd))
        {
            e->keep_dest_busy = TRUE;
        }
    }
}

static void
set_waw_lock_fp_dest(RISCVCPUState *s, CPUStage *stage, int rd)
{
    InstructionLatch *e;

    if (stage->has_data)
    {
        e = get_insn_latch(s->simcpu->insn_latch_pool, stage->insn_latch_index);
        if (e->ins.has_fp_dest && (e->ins.rd == rd))
        {
            e->keep_dest_busy = TRUE;
        }
    }
}

static int
execute_stage_busy(const INCore *core, int *busy_stage_id)
{
    int i;

    for (i = 0; i < core->simcpu->params->num_alu_stages; ++i)
    {
        if (core->ialu[i].has_data)
        {
            *busy_stage_id = FU_ALU;
            return TRUE;
        }
    }

    for (i = 0; i < core->simcpu->params->num_mul_stages; ++i)
    {
        if (core->imul[i].has_data)
        {
            *busy_stage_id = FU_MUL;
            return TRUE;
        }
    }

    for (i = 0; i < core->simcpu->params->num_div_stages; ++i)
    {
        if (core->idiv[i].has_data)
        {
            *busy_stage_id = FU_DIV;
            return TRUE;
        }
    }

    for (i = 0; i < core->simcpu->params->num_fpu_fma_stages; ++i)
    {
        if (core->fpu_fma[i].has_data)
        {
            *busy_stage_id = FU_FPU_FMA;
            return TRUE;
        }
    }

    if (core->fpu_alu.has_data)
    {
        *busy_stage_id = FU_FPU_ALU;
        return TRUE;
    }

    /* All the functional units are free */
    return FALSE;
}

static int
target_fu_pipelined(const INCore *core, int fu_type)
{
    int num_stages = 1;

    switch (fu_type)
    {
        case FU_ALU:
        {
            num_stages = core->simcpu->params->num_alu_stages;
            break;
        }
        case FU_MUL:
        {
            num_stages = core->simcpu->params->num_mul_stages;
            break;
        }
        case FU_DIV:
        {
            num_stages = core->simcpu->params->num_div_stages;
            break;
        }
        case FU_FPU_ALU:
        {
            break;
        }
        case FU_FPU_FMA:
        {
            num_stages = core->simcpu->params->num_fpu_fma_stages;
            break;
        }
    }

    if (num_stages > 1)
    {
        return TRUE;
    }

    return FALSE;
}

void
in_core_decode(INCore *core)
{
    int i;
    InstructionLatch *e;
    RISCVCPUState *s;
    int ins_issue_index;
    int busy_stage_id = -1;
    int read_int_rf = 0;
    int read_fp_rf = 0;

    s = core->simcpu->emu_cpu_state;
    if (core->decode.has_data)
    {
        e = get_insn_latch(s->simcpu->insn_latch_pool,
                           core->decode.insn_latch_index);
        if (!core->decode.stage_exec_done)
        {
            if (!e->is_decoded)
            {
                decode_cpu_stage_exec(s, e);
                if (s->simcpu->bpu_decode_stage_handler(s, e))
                {
                    /* RAS has redirected the control flow, so flush */
                    cpu_stage_flush_free_insn_latch(&core->fetch,
                                                    s->simcpu->insn_latch_pool);
                    cpu_stage_flush_free_insn_latch(&core->pcgen,
                                                    s->simcpu->insn_latch_pool);
                    core->pcgen.has_data = TRUE;
                }
                e->is_decoded = TRUE;
            }

            /* Handle exception caused during decoding */
            if (unlikely(e->ins.exception))
            {
                sim_exception_set(s->simcpu->exception, e);
                cpu_stage_flush(&core->pcgen);
                cpu_stage_flush(&core->fetch);
                cpu_stage_flush(&core->decode);
                return;
            }

            /* Read integer operands */
            read_int_operand(core, e->ins.has_src1, &e->read_rs1, e->ins.rs1,
                             &e->ins.rs1_val, &read_int_rf);
            read_int_operand(core, e->ins.has_src2, &e->read_rs2, e->ins.rs2,
                             &e->ins.rs2_val, &read_int_rf);

            /* Read floating-point operands */
            read_fp_operand(core, e->ins.has_fp_src1, &e->read_rs1, e->ins.rs1,
                            &e->ins.rs1_val, &read_fp_rf);
            read_fp_operand(core, e->ins.has_fp_src2, &e->read_rs2, e->ins.rs2,
                            &e->ins.rs2_val, &read_fp_rf);
            read_fp_operand(core, e->ins.has_fp_src3, &e->read_rs3, e->ins.rs3,
                            &e->ins.rs3_val, &read_fp_rf);

            /* Stall if any of the source register value is not available */
            if (((e->ins.has_src1 || e->ins.has_fp_src1) && !e->read_rs1)
                || ((e->ins.has_src2 || e->ins.has_fp_src2) && !e->read_rs2)
                || (e->ins.has_fp_src3 && !e->read_rs3))
            {
                goto exit_decode;
            }

            /**
             * Check if any of the issued instructions are writing to the same
             * register (WAW hazard) and keep the destination busy until WAW
             * hazard is resolved.
             */
            if (e->ins.has_dest)
            {
                if (!core->int_reg_status[e->ins.rd])
                {
                    set_waw_lock_int_dest(s, &core->commit, e->ins.rd);
                    set_waw_lock_int_dest(s, &core->memory, e->ins.rd);
                    set_waw_lock_int_dest(s, &core->fpu_alu, e->ins.rd);
                    for (i = s->simcpu->params->num_div_stages - 1; i >= 0; i--)
                    {
                        set_waw_lock_int_dest(s, &core->idiv[i], e->ins.rd);
                    }
                    for (i = s->simcpu->params->num_mul_stages - 1; i >= 0; i--)
                    {
                        set_waw_lock_int_dest(s, &core->imul[i], e->ins.rd);
                    }
                    for (i = s->simcpu->params->num_alu_stages - 1; i >= 0; i--)
                    {
                        set_waw_lock_int_dest(s, &core->ialu[i], e->ins.rd);
                    }
                }
            }

            if (e->ins.has_fp_dest)
            {
                if (!core->fp_reg_status[e->ins.rd])
                {
                    set_waw_lock_fp_dest(s, &core->commit, e->ins.rd);
                    set_waw_lock_fp_dest(s, &core->memory, e->ins.rd);
                    for (i = s->simcpu->params->num_fpu_fma_stages - 1; i >= 0;
                         i--)
                    {
                        set_waw_lock_fp_dest(s, &core->fpu_fma[i], e->ins.rd);
                    }
                    set_waw_lock_fp_dest(s, &core->fpu_alu, e->ins.rd);
                }
            }

            core->decode.stage_exec_done = TRUE;
        }

        if (!core->simcpu->params->enable_parallel_fu
            && execute_stage_busy(core, &busy_stage_id))
        {
            if (!(target_fu_pipelined(core, e->ins.fu_type)
                  && (e->ins.fu_type == busy_stage_id)))
            {
                goto exit_decode;
            }
        }

        /* Decoding is complete and all the resources are acquired. If the
         * required FU is free, issue the instruction to the appropriate FU,
         * else stall */
        switch (e->ins.fu_type)
        {
            case FU_ALU:
                if (!core->ialu[0].has_data)
                {
                    core->decode.stage_exec_done = FALSE;
                    core->ialu[0] = core->decode;
                }
                else
                {
                    goto exit_decode;
                }
                break;
            case FU_MUL:
                if (!core->imul[0].has_data)
                {
                    core->decode.stage_exec_done = FALSE;
                    core->imul[0] = core->decode;
                }
                else
                {
                    goto exit_decode;
                }
                break;
            case FU_DIV:
                if (!core->idiv[0].has_data)
                {
                    core->decode.stage_exec_done = FALSE;
                    core->idiv[0] = core->decode;
                }
                else
                {
                    goto exit_decode;
                }
                break;
            case FU_FPU_ALU:
                if (!core->fpu_alu.has_data)
                {
                    core->decode.stage_exec_done = FALSE;
                    core->fpu_alu = core->decode;
                }
                else
                {
                    goto exit_decode;
                }
                break;
            case FU_FPU_FMA:
                if (!core->fpu_fma[0].has_data)
                {
                    core->decode.stage_exec_done = FALSE;
                    core->fpu_fma[0] = core->decode;
                }
                else
                {
                    goto exit_decode;
                }
                break;
        }

        /* Add sequence number of this instruction to memory selection queue */
        ins_issue_index = cq_enqueue(&core->ex_to_mem_queue.cq);

        sim_assert((ins_issue_index != -1), "error: %s at line %d in %s(): %s",
                   __FILE__, __LINE__, __func__,
                   "EX stage to MEM stage instruction selector queue full");

        core->ex_to_mem_queue.data[ins_issue_index] = e->ins_dispatch_id;
        cpu_stage_flush(&core->decode);
    }
exit_decode:
    if (read_int_rf)
    {
        s->simcpu->stats[s->priv].int_regfile_reads++;
    }

    if (read_fp_rf)
    {
        s->simcpu->stats[s->priv].fp_regfile_reads++;
    }
}

/*=====  End of Instruction Decode Stage  ======*/