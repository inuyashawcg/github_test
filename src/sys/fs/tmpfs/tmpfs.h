/*	$NetBSD: tmpfs.h,v 1.26 2007/02/22 06:37:00 thorpej Exp $	*/

/*-
 * SPDX-License-Identifier: BSD-2-Clause-NetBSD
 *
 * Copyright (c) 2005, 2006 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Julio M. Merino Vidal, developed as part of Google's Summer of Code
 * 2005 program.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: releng/12.0/sys/fs/tmpfs/tmpfs.h 326998 2017-12-19 20:19:07Z jhb $
 */

#ifndef _FS_TMPFS_TMPFS_H_
#define _FS_TMPFS_TMPFS_H_

#include <sys/queue.h>
#include <sys/tree.h>

#ifdef	_SYS_MALLOC_H_
MALLOC_DECLARE(M_TMPFSMNT);
MALLOC_DECLARE(M_TMPFSNAME);
#endif

/*
 * Internal representation of a tmpfs directory entry.
 * tmpfs 目录项的内部表示形式
 */

LIST_HEAD(tmpfs_dir_duphead, tmpfs_dirent);

struct tmpfs_dirent {
	/*
	 * Depending on td_cookie flag entry can be of 3 types:
	 * - regular -- no hash collisions, stored in RB-Tree
	 * - duphead -- synthetic linked list head for dup entries
	 * - dup -- stored in linked list instead of RB-Tree
	 * 
	 * 根据 td_cookie 标志，entry 可以分成3中类型：
	 * 	常规类型 - 没有 hash 冲突，存储在红黑树
	 * 	duphead - 为 dup entry 生成一个链表头
	 * 	dup - 保存到链表而不是红黑树中
	 */
	union {
		/* regular and duphead entry types */
		RB_ENTRY(tmpfs_dirent)		td_entries;

		/* dup entry type */
		struct {
			LIST_ENTRY(tmpfs_dirent) entries;
			LIST_ENTRY(tmpfs_dirent) index_entries;
		} td_dup;
	} uh;

	uint32_t			td_cookie;
	uint32_t			td_hash;
	u_int				td_namelen;

	/*
	 * Pointer to the node this entry refers to.  In case this field
	 * is NULL, the node is a whiteout.
	 * 指向此项所引用的节点的指针。如果此字段为空，则节点为白色(红黑树相关)
	 */
	struct tmpfs_node *		td_node;

	union {
		/*
		 * The name of the entry, allocated from a string pool.  This
		 * string is not required to be zero-terminated.
		 * 从字符串池中分配的项的名称。此字符串不需要以零结尾
		 */
		char *			td_name;	/* regular, dup */
		struct tmpfs_dir_duphead td_duphead;	/* duphead - list head */
	} ud;
};

/*
 * A directory in tmpfs holds a collection of directory entries, which
 * in turn point to other files (which can be directories themselves).
 * tmpfs 中的目录包含目录项的集合，这些目录项又指向其他文件（这些文件本身可以是目录）
 *
 * In tmpfs, this collection is managed by a RB-Tree, whose head is
 * defined by the struct tmpfs_dir type.
 * 在 tmpfs 中，这个集合由 RB 树管理，RB 树的头由 struct tmpfs_dir 类型定义
 *
 * It is important to notice that directories do not have entries for . and
 * .. as other file systems do.  These can be generated when requested
 * based on information available by other means, such as the pointer to
 * the node itself in the former case or the pointer to the parent directory
 * in the latter case.  This is done to simplify tmpfs's code and, more
 * importantly, to remove redundancy.
 * 需要注意的是，目录中没有的条目. 和 .. 和其他文件系统一样。当请求时，可以根据通过其他方式
 * 获得的信息生成这些信息，例如在前一种情况下指向节点本身的指针或在后一种情况下指向父目录的指针。
 * 这样做是为了简化 tmpfs 的代码，更重要的是，删除冗余
 */
RB_HEAD(tmpfs_dir, tmpfs_dirent);

/*
 * Each entry in a directory has a cookie that identifies it.  Cookies
 * supersede offsets within directories because, given how tmpfs stores
 * directories in memory, there is no such thing as an offset.
 * 目录中的每个条目都有一个标识它的 cookie。Cookies 会取代目录中的偏移量，因为考虑到 tmpfs
 * 在内存中存储目录的方式，不存在偏移量
 *
 * The '.', '..' and the end of directory markers have fixed cookies which
 * cannot collide with the cookies generated by other entries.  The cookies
 * for the other entries are generated based on the file name hash value or
 * unique number in case of name hash collision.
 * “.”、“..”和目录结尾标记具有固定的 Cookie，这些 Cookie 不能与其他条目生成的 Cookie 冲突。
 * 其他条目的 cookies 是基于文件名哈希值或唯一数字生成的，以防名称哈希冲突
 *
 * To preserve compatibility cookies are limited to 31 bits.
 * 为保持兼容性，Cookie 限制为31位
 */

#define	TMPFS_DIRCOOKIE_DOT		0
#define	TMPFS_DIRCOOKIE_DOTDOT		1
#define	TMPFS_DIRCOOKIE_EOF		2
#define	TMPFS_DIRCOOKIE_MASK		((off_t)0x3fffffffU)
#define	TMPFS_DIRCOOKIE_MIN		((off_t)0x00000004U)
#define	TMPFS_DIRCOOKIE_DUP		((off_t)0x40000000U)
#define	TMPFS_DIRCOOKIE_DUPHEAD		((off_t)0x80000000U)
#define	TMPFS_DIRCOOKIE_DUP_MIN		TMPFS_DIRCOOKIE_DUP
#define	TMPFS_DIRCOOKIE_DUP_MAX		\
	(TMPFS_DIRCOOKIE_DUP | TMPFS_DIRCOOKIE_MASK)

/*
 * Internal representation of a tmpfs file system node.
 *
 * This structure is splitted in two parts: one holds attributes common
 * to all file types and the other holds data that is only applicable to
 * a particular type.  The code must be careful to only access those
 * attributes that are actually allowed by the node's type.
 * 此结构分为两部分：一部分保存所有文件类型的公共属性，另一部分保存仅适用于特定类型的数据。
 * 代码必须注意只访问节点类型实际允许的那些属性
 *
 * Below is the key of locks used to protected the fields in the following
 * structures.
 * 括号表示的意思其实就是对应的数据被哪些锁保护着
 * 
 * (v)  vnode lock in exclusive mode
 * (vi) vnode lock in exclusive mode, or vnode lock in shared vnode and
 *	tn_interlock
 * (i)  tn_interlock
 * (m)  tmpfs_mount tm_allnode_lock
 * (c)  stable after creation
 * 
 * 从注释中可以看到一个简单的文件系统是如何管理结点的，其中有一种方式就是利用双链表。
 * 这样做的好处就是对于查找、增删等操作会比较方便高效
 */
struct tmpfs_node {
	/*
	 * Doubly-linked list entry which links all existing nodes for
	 * a single file system.  This is provided to ease the removal
	 * of all nodes during the unmount operation, and to support
	 * the implementation of VOP_VNTOCNP().  tn_attached is false
	 * when the node is removed from list and unlocked.
	 * 链接单个文件系统的所有现有节点的双链接列表项。这是为了在卸载操作期间简化所有
	 * 节点的删除，并支持 VOP_VNTOCNP 的实现。当节点从列表中移除并解锁时，
	 * tn_attached 为 false
	 */
	LIST_ENTRY(tmpfs_node)	tn_entries;	/* (m) 通过双端链表管理结点 */
	bool			tn_attached;	/* (m) 标记该结点是否已经从链表中删除 */

	/*
	 * The node's type.  Any of 'VBLK', 'VCHR', 'VDIR', 'VFIFO',
	 * 'VLNK', 'VREG' and 'VSOCK' is allowed.  The usage of vnode
	 * types instead of a custom enumeration is to make things simpler
	 * and faster, as we do not need to convert between two types.
	 * 使用vnode类型而不是自定义枚举是为了使事情更简单、更快，因为我们不需要在两种
	 * 类型之间进行转换
	 */
	enum vtype		tn_type;	/* (c) 结点的类型 */

	/* Node identifier. */
	ino_t			tn_id;		/* (c) 结点id，用于识别特定结点 */

	/*
	 * Node's internal status.  This is used by several file system
	 * operations to do modifications to the node in a delayed
	 * fashion.
	 * 节点的内部状态。多个文件系统操作使用它以延迟方式对节点进行修改
	 */
	int			tn_status;	/* (vi) */
#define	TMPFS_NODE_ACCESSED	(1 << 1)
#define	TMPFS_NODE_MODIFIED	(1 << 2)
#define	TMPFS_NODE_CHANGED	(1 << 3)

	/*
	 * The node size.  It does not necessarily match the real amount
	 * of memory consumed by it.
	 * 节点大小。它不一定与它所消耗的实际内存量相匹配
	 */
	off_t			tn_size;	/* (v) */

	/* Generic node attributes. 结点通常具有的一些属性 */
	uid_t			tn_uid;		/* (v) */
	gid_t			tn_gid;		/* (v) */
	mode_t			tn_mode;	/* (v) */
	int			tn_links;	/* (v) */
	u_long			tn_flags;	/* (v) */
	struct timespec		tn_atime;	/* (vi) */
	struct timespec		tn_mtime;	/* (vi) */
	struct timespec		tn_ctime;	/* (vi) */
	struct timespec		tn_birthtime;	/* (v) */
	unsigned long		tn_gen;		/* (c) */

	/*
	 * As there is a single vnode for each active file within the
	 * system, care has to be taken to avoid allocating more than one
	 * vnode per file.  In order to do this, a bidirectional association
	 * is kept between vnodes and nodes.
	 *
	 * Whenever a vnode is allocated, its v_data field is updated to
	 * point to the node it references.  At the same time, the node's
	 * tn_vnode field is modified to point to the new vnode representing
	 * it.  Further attempts to allocate a vnode for this same node will
	 * result in returning a new reference to the value stored in
	 * tn_vnode.
	 *
	 * May be NULL when the node is unused (that is, no vnode has been
	 * allocated for it or it has been reclaimed).
	 */
	struct vnode *		tn_vnode;	/* (i) */

	/*
	 * Interlock to protect tn_vpstate, and tn_status under shared
	 * vnode lock.
	 */
	struct mtx	tn_interlock;

	/*
	 * Identify if current node has vnode assiocate with
	 * or allocating vnode.
	 */
	int		tn_vpstate;		/* (i) */

	/* Transient(临时的) refcounter on this node. */
	u_int		tn_refcount;		/* (m) + (i) */

	/* misc data field for different tn_type node 
		这个 union 表示的不同类型的 node 的一些特殊的数据成员。上面的成员都是每个节点共有的属性，包括时间、UID等。
		这些其实都是一个文件必备的基本信息，所以可以认定 tmpfs_node 就表示一个文件。
		tmpfs_dirent 对应目录下的一个目录项。目录项也是一个文件，只不过目录会通过 tmpfs_dirent 来对这些文件(node)
		进行管理，比如使用链表或者是用红黑树联系起来。
	*/
	union {
		/* Valid when tn_type == VBLK || tn_type == VCHR. 
			如果该节点表示的是一个设备节点，这里就只放一个设备指针
		*/
		dev_t			tn_rdev;	/* (c) */

		/* Valid when tn_type == VDIR. */
		struct tn_dir {
			/*
			 * Pointer to the parent directory.  The root
			 * directory has a pointer to itself in this field;
			 * this property identifies the root node.
			 * 如果该节点表示的是一个目录，首先要有一个指针指向的它的父节点(如下)。如果该节点是根节点，
			 * 则该指针指向它自己。我们可以利用它来判断是否是根节点
			 */
			struct tmpfs_node *	tn_parent;

			/*
			 * Head of a tree that links the contents of
			 * the directory together.
			 * tmpfs_dir 是红黑树的根节点，然后整个头文件中只有这一个地方会用到，说明整个文件系统的目录项
			 * 是利用红黑树管理起来的。
			 */
			struct tmpfs_dir	tn_dirhead;

			/*
			 * Head of a list the contains fake directory entries
			 * heads, i.e. entries with TMPFS_DIRCOOKIE_DUPHEAD
			 * flag.
			 */
			struct tmpfs_dir_duphead tn_dupindex;

			/*
			 * Number and pointer of the first directory entry
			 * returned by the readdir operation if it were
			 * called again to continue reading data from the
			 * same directory as before.  This is used to speed
			 * up reads of long directories, assuming that no
			 * more than one read is in progress at a given time.
			 * Otherwise, these values are discarded.
			 */
			off_t			tn_readdir_lastn;
			struct tmpfs_dirent *	tn_readdir_lastp;
		} tn_dir;

		/* Valid when tn_type == VLNK. */
		/* The link's target, allocated from a string pool. */
		char *			tn_link;	/* (c) */

		/* Valid when tn_type == VREG. */
		struct tn_reg {
			/*
			 * The contents of regular files stored in a
			 * tmpfs file system are represented by a
			 * single anonymous memory object (aobj, for
			 * short).  The aobj provides direct access to
			 * any position within the file.  It is a task
			 * of the memory management subsystem to issue
			 * the required page ins or page outs whenever
			 * a position within the file is accessed.
			 * 
			 * tmpfs 文件系统中存储的常规文件的内容由单个匿名内存对象（简称aobj）表示。
			 * aobj 提供对文件中任何位置的直接访问。内存管理子系统的一项任务是，每当访问
			 * 文件中的某个位置时，就发出所需的页入或页出。
			 */
			vm_object_t		tn_aobj;	/* (c) */
		} tn_reg;
	} tn_spec;	/* (v) */
};

// 定义一个全局的 tmpfs_node 链表
LIST_HEAD(tmpfs_node_list, tmpfs_node);

#define tn_rdev tn_spec.tn_rdev
#define tn_dir tn_spec.tn_dir
#define tn_link tn_spec.tn_link
#define tn_reg tn_spec.tn_reg
#define tn_fifo tn_spec.tn_fifo

#define	TMPFS_LINK_MAX INT_MAX

/*
	奇海设备树应该是对所有的进程开放的，所以应该需要考虑多线程同时访问树节点。参考这里 interlock
	设计，在树节点中添加一个锁成员来保护可能会被改变的成员
*/
#define TMPFS_NODE_LOCK(node) mtx_lock(&(node)->tn_interlock)
#define TMPFS_NODE_UNLOCK(node) mtx_unlock(&(node)->tn_interlock)
#define TMPFS_NODE_MTX(node) (&(node)->tn_interlock)
#define	TMPFS_NODE_ASSERT_LOCKED(node) mtx_assert(TMPFS_NODE_MTX(node), \
    MA_OWNED)

#ifdef INVARIANTS
#define TMPFS_ASSERT_LOCKED(node) do {					\
		MPASS((node) != NULL);					\
		MPASS((node)->tn_vnode != NULL);			\
		ASSERT_VOP_LOCKED((node)->tn_vnode, "tmpfs assert");	\
	} while (0)
#else
#define TMPFS_ASSERT_LOCKED(node) (void)0
#endif

/* 
	刚好对应的是8421，与或非操作的时候可以通过检查其值是否为0来判断
	结点当前的是否具有某种属性
*/
#define TMPFS_VNODE_ALLOCATING	1
#define TMPFS_VNODE_WANT	2
#define TMPFS_VNODE_DOOMED	4
#define	TMPFS_VNODE_WRECLAIM	8

/*
 * Internal representation of a tmpfs mount point.
		设计 filetree 类的时候，要参考该结构体中的成员，尤其是包含的锁。分析代码实现的时候也是要
		重点关注锁是怎么用的
 */
struct tmpfs_mount {
	/*
	 * Maximum number of memory pages available for use by the file
	 * system, set during mount time.  This variable must never be
	 * used directly as it may be bigger than the current amount of
	 * free memory; in the extreme case, it will hold the ULONG_MAX
	 * value.
	 * 文件系统可使用的最大内存页数，在装载期间设置。决不能直接使用此变量，因为
	 * 它可能大于当前可用内存量；在极端情况下，它将保持 ULONG_MAX 值
	 */
	u_long			tm_pages_max;

	/* Number of pages in use by the file system. 
		系统已经使用的内存页
	*/
	u_long			tm_pages_used;

	/*
	 * Pointer to the node representing the root directory of this
	 * file system.
	 * 指向表示此文件系统根目录的节点的指针
	 */
	struct tmpfs_node *	tm_root;

	/*
	 * Maximum number of possible nodes for this file system; set
	 * during mount time.  We need a hard limit on the maximum number
	 * of nodes to avoid allocating too much of them; their objects
	 * cannot be released until the file system is unmounted.
	 * Otherwise, we could easily run out of memory by creating lots
	 * of empty files and then simply removing them.
	 * 
	 * 此文件系统的最大可能节点数；安装时设置。我们需要对节点的最大数量进行严格限制，
	 * 以避免分配过多的节点；在卸载文件系统之前，无法释放它们的对象。否则，我们可以
	 * 创建大量空文件，然后简单地删除它们，从而很容易耗尽内存
	 */
	ino_t			tm_nodes_max;

	/* unrhdr used to allocate inode numbers 
		unrhdr用于分配inode编号
	*/
	struct unrhdr *		tm_ino_unr;

	/* Number of nodes currently that are in use. 
		当前已经使用的 vnode 的数量
	*/
	ino_t			tm_nodes_inuse;

	/* Refcounter on this struct tmpfs_mount. */
	uint64_t		tm_refcount;

	/* maximum representable file size 
		最大可表示的文件大小
	*/
	u_int64_t		tm_maxfilesize;

	/*
	 * The used list contains all nodes that are currently used by
	 * the file system; i.e., they refer to existing files.
	 * 被文件系统已经使用的结点链表，它们表示已经存在的节点。在 tmpfs 中表示 tmpfs_node 链表头
	 * 的结构只有这里被用到了，说明 mount 的时候文件系统会建立一个 node 链表，但是这个链表应该不是
	 * 保存文件系统中所有的节点，推测只是保存根目录下的所有node。
	 * tmpfs_alloc_node 函数中包含向 tm_nodes_used 插入新创建节点的步骤，说明我只要申请一个节点，
	 * 就要往 tm_nodes_used 中添加一个元素，文件系统的所有文件节点都通过一个链表来管理，挺奇怪的
	 */
	struct tmpfs_node_list	tm_nodes_used;

	/* All node lock to protect the node list and tmp_pages_used. 
		所有的结点锁都用来保护 node list 和 tmp_pages_used
	*/
	struct mtx		tm_allnode_lock;

	/* Zones used to store file system meta data, per tmpfs mount. 
		申请 uma 结构体用来专门存储文件系统元数据
	*/
	uma_zone_t		tm_dirent_pool;
	uma_zone_t		tm_node_pool;

	/* Read-only status. */
	bool			tm_ronly;
	/* Do not use namecache. */
	bool			tm_nonc;
};
#define	TMPFS_LOCK(tm) mtx_lock(&(tm)->tm_allnode_lock)
#define	TMPFS_UNLOCK(tm) mtx_unlock(&(tm)->tm_allnode_lock)
#define	TMPFS_MP_ASSERT_LOCKED(tm) mtx_assert(&(tm)->tm_allnode_lock, MA_OWNED)

/*
 * This structure maps a file identifier to a tmpfs node.  Used by the
 * NFS code.
 * 此结构将文件标识符映射到 tmpfs 节点。由 NFS 代码使用
 */
struct tmpfs_fid {
	uint16_t		tf_len;
	uint16_t		tf_pad;
	ino_t			tf_id;
	unsigned long		tf_gen;
};

/* tmpfs directory cursor: tmpfs 目录光标？ */
struct tmpfs_dir_cursor {
	struct tmpfs_dirent	*tdc_current;
	struct tmpfs_dirent	*tdc_tree;
};

#ifdef _KERNEL
/*
 * Prototypes for tmpfs_subr.c.
 */

void	tmpfs_ref_node(struct tmpfs_node *node);
void	tmpfs_ref_node_locked(struct tmpfs_node *node);
int	tmpfs_alloc_node(struct mount *mp, struct tmpfs_mount *, enum vtype,
	    uid_t uid, gid_t gid, mode_t mode, struct tmpfs_node *,
	    char *, dev_t, struct tmpfs_node **);
void	tmpfs_free_node(struct tmpfs_mount *, struct tmpfs_node *);
bool	tmpfs_free_node_locked(struct tmpfs_mount *, struct tmpfs_node *, bool);
void	tmpfs_free_tmp(struct tmpfs_mount *);
int	tmpfs_alloc_dirent(struct tmpfs_mount *, struct tmpfs_node *,
	    const char *, u_int, struct tmpfs_dirent **);
void	tmpfs_free_dirent(struct tmpfs_mount *, struct tmpfs_dirent *);
void	tmpfs_dirent_init(struct tmpfs_dirent *, const char *, u_int);
void	tmpfs_destroy_vobject(struct vnode *vp, vm_object_t obj);
int	tmpfs_alloc_vp(struct mount *, struct tmpfs_node *, int,
	    struct vnode **);
void	tmpfs_free_vp(struct vnode *);
int	tmpfs_alloc_file(struct vnode *, struct vnode **, struct vattr *,
	    struct componentname *, char *);
void	tmpfs_check_mtime(struct vnode *);
void	tmpfs_dir_attach(struct vnode *, struct tmpfs_dirent *);
void	tmpfs_dir_detach(struct vnode *, struct tmpfs_dirent *);
void	tmpfs_dir_destroy(struct tmpfs_mount *, struct tmpfs_node *);
struct tmpfs_dirent *	tmpfs_dir_lookup(struct tmpfs_node *node,
			    struct tmpfs_node *f,
			    struct componentname *cnp);
int	tmpfs_dir_getdents(struct tmpfs_node *, struct uio *, int,
	    u_long *, int *);
int	tmpfs_dir_whiteout_add(struct vnode *, struct componentname *);
void	tmpfs_dir_whiteout_remove(struct vnode *, struct componentname *);
int	tmpfs_reg_resize(struct vnode *, off_t, boolean_t);
int	tmpfs_chflags(struct vnode *, u_long, struct ucred *, struct thread *);
int	tmpfs_chmod(struct vnode *, mode_t, struct ucred *, struct thread *);
int	tmpfs_chown(struct vnode *, uid_t, gid_t, struct ucred *,
	    struct thread *);
int	tmpfs_chsize(struct vnode *, u_quad_t, struct ucred *, struct thread *);
int	tmpfs_chtimes(struct vnode *, struct vattr *, struct ucred *cred,
	    struct thread *);
void	tmpfs_itimes(struct vnode *, const struct timespec *,
	    const struct timespec *);

void	tmpfs_set_status(struct tmpfs_node *node, int status);
void	tmpfs_update(struct vnode *);
int	tmpfs_truncate(struct vnode *, off_t);
struct tmpfs_dirent *tmpfs_dir_first(struct tmpfs_node *dnode,
	    struct tmpfs_dir_cursor *dc);
struct tmpfs_dirent *tmpfs_dir_next(struct tmpfs_node *dnode,
	    struct tmpfs_dir_cursor *dc);

/*
 * Convenience macros to simplify some logical expressions.
 */
#define IMPLIES(a, b) (!(a) || (b))
#define IFF(a, b) (IMPLIES(a, b) && IMPLIES(b, a))

/*
 * Checks that the directory entry pointed by 'de' matches the name 'name'
 * with a length of 'len'.
 */
#define TMPFS_DIRENT_MATCHES(de, name, len) \
    (de->td_namelen == len && \
    bcmp((de)->ud.td_name, (name), (de)->td_namelen) == 0)

/*
 * Ensures that the node pointed by 'node' is a directory and that its
 * contents are consistent with respect to directories.
 * 确保“节点”指向的节点是目录，并且其内容与目录一致
 */
#define TMPFS_VALIDATE_DIR(node) do { \
	MPASS((node)->tn_type == VDIR); \
	MPASS((node)->tn_size % sizeof(struct tmpfs_dirent) == 0); \
} while (0)

/*
 * Amount of memory pages to reserve for the system (e.g., to not use by
 * tmpfs).
 * 为系统保留的内存页，tmpfs是不能动的
 */
#define TMPFS_PAGES_MINRESERVED		(4 * 1024 * 1024 / PAGE_SIZE)

size_t tmpfs_mem_avail(void);

size_t tmpfs_pages_used(struct tmpfs_mount *tmp);

#endif

/*
 * Macros/functions to convert from generic data structures to tmpfs
 * specific ones.
 * 把 mount->mnt_data 转换为 tmpfs_mount 类型，应该是每个文件系统通用的做法
 */

static inline struct tmpfs_mount *
VFS_TO_TMPFS(struct mount *mp)
{
	struct tmpfs_mount *tmp;

	MPASS(mp != NULL && mp->mnt_data != NULL);
	tmp = (struct tmpfs_mount *)mp->mnt_data;
	return (tmp);
}

static inline struct tmpfs_node *
VP_TO_TMPFS_NODE(struct vnode *vp)
{
	struct tmpfs_node *node;

	MPASS(vp != NULL && vp->v_data != NULL);
	node = (struct tmpfs_node *)vp->v_data;
	return (node);
}

static inline struct tmpfs_node *
VP_TO_TMPFS_DIR(struct vnode *vp)
{
	struct tmpfs_node *node;

	node = VP_TO_TMPFS_NODE(vp);
	TMPFS_VALIDATE_DIR(node);
	return (node);
}

static inline bool
tmpfs_use_nc(struct vnode *vp)
{

	return (!(VFS_TO_TMPFS(vp->v_mount)->tm_nonc));
}

#endif /* _FS_TMPFS_TMPFS_H_ */
